<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":15},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MaxSoft">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MaxSoft">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="maxsoft">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>MaxSoft</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MaxSoft</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">「路漫漫其修远兮，吾将上下而求索」</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/27/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/27/hello-world/" class="post-title-link" itemprop="url">Hello World MaxSoft 2020-01-20 PM 11:00</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2020-01-27 15:25:09" itemprop="dateCreated datePublished" datetime="2020-01-27T15:25:09+08:00">2020-01-27</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>357</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/16/Java%20%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/16/Java%20%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Java 中关于对象的引用小结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2017-10-16 14:15:30" itemprop="dateCreated datePublished" datetime="2017-10-16T14:15:30+08:00">2017-10-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Java 语言中为了达到更加灵活的控制对象的生命周期的目的。在 JDK 1.2版本后引入了对象的引用类型，其中分为四种，分别有强引用（StrongReference），软引用（SoftReference），弱引用（WeakReference ）和虚引用（PhantomReference）；</p>
<h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>强引用（StrongReference）</font>是 Java 的默认引用实现，它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时 GC 执行后将会被回收。当然，当内存空间不足时 JVM 宁可抛出 OutOfMemoryError 错误，也不会靠随意回收具有强引用的对象来解决内存不足的问题。<br>如下代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String test_strong_reference = <span class="string">"MaxSoft"</span>; <span class="comment">// 强引用类型</span></span><br><span class="line">Object maxsoft = <span class="keyword">new</span> Object(); <span class="comment">// 强引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以下代码如果内存容量不足，则会抛出OOM异常 即 内存空间不足时 JVM 宁可抛出 </span></span><br><span class="line"><span class="comment">OutOfMemoryError 错误，也不会靠随意回收具有强引用的对象来解决内存不足的问题 **/</span></span><br><span class="line">Object[] strong_refers = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">Object[] strong_refers1 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">Object[] strong_refers2 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">Object[] strong_refers3 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">Object[] strong_refers4 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br></pre></td></tr></table></figure>
<p>当然，如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样JVM在合适的时间就会回收该对象。<br>如下代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码段是摘自 java.util.concurrent.ArrayBlockingQueue 中的片段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> i = lastRet;</span><br><span class="line">	<span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	lastRet = -<span class="number">1</span>;</span><br><span class="line">	E x = lastItem;</span><br><span class="line">	lastItem = <span class="keyword">null</span>; <span class="comment">// 这里交给了 GC 来进行后续的内存回收工作</span></span><br><span class="line">	<span class="comment">// only remove if item still at index</span></span><br><span class="line">	<span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x == items[i]) &#123;</span><br><span class="line">	    <span class="keyword">boolean</span> removingHead = (i == takeIndex);</span><br><span class="line">	    removeAt(i);</span><br><span class="line">	    <span class="keyword">if</span> (!removingHead)</span><br><span class="line">		nextIndex = dec(nextIndex);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>软引用（SoftReference）</font>如果一个对象只具有软引用，那就类似于我们日常工作台上的花瓶可有可无，如果工作台的面积足够大，我们就可能一直会将花瓶摆设下去，如果工作台面积不够，那我们一定会移除它来摆设其他必须的用品。JVM对软引用的对象内存回收也是如此，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联 合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_soft_refer</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Object soft_refer = <span class="keyword">new</span>  Object();  </span><br><span class="line">   SoftReference obj_soft_refer=<span class="keyword">new</span> SoftReference(soft_refer); </span><br><span class="line">   <span class="comment">// 此时 soft_refer 是一个强引用对象</span></span><br><span class="line">   soft_refer = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 此时 soft_refer 变为了一个软引用对象，当JVM内存不足时即会被回收掉</span></span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">     Object[] strong_refers = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers1 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     System.out.println(<span class="string">"-------&gt;"</span> + (obj_soft_refer.get()==<span class="keyword">null</span>)); <span class="comment">// false</span></span><br><span class="line">     Object[] strong_refers2 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers3 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers4 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">/** 结果为 true； </span></span><br><span class="line"><span class="comment">         如果前面不将 soft_refer = null; 则结果为false,因为此时 soft_refer 为强引用；</span></span><br><span class="line"><span class="comment">         否则即为true，这是由于前面发生了OOM而soft_refer被回收了； **/</span></span><br><span class="line">     System.out.println(<span class="string">"-------&gt;"</span> + (obj_soft_refer.get()==<span class="keyword">null</span>)); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们可以在上述示例代码中发现，在内存不足时虽然清除掉了soft_refer 对象，但是任然保留了 obj_soft_refer 对象。那么问题来了，我们是不是也要将其清除掉呢？<br>其实 SoftReference 作为一个Java对象，除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个 SoftReference 对象的 get() 方法返回 null ,但这个SoftReference 对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。所以在java.lang.ref包里还提供了 ReferenceQueue 。在创建 SoftReference 对象的时候，使用了一个 ReferenceQueue 对象作为参数提供给 SoftReference 的构造方法，如示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span>  ReferenceQueue();  </span><br><span class="line">SoftReference  obj_soft_refer=<span class="keyword">new</span>  SoftReference(soft_refer, queue);</span><br></pre></td></tr></table></figure>
<p>当上述示例中 SoftReference 所软引用的 soft_refer 被垃圾收集器回收的同时， obj_soft_refer 所强引用的 SoftReference 对象也将被列入 ReferenceQueue 。换句话说就是 ReferenceQueue 中保存的对象是    Reference 对象，而且是已经失去了它所软引用的对象的 Reference 对象。我们从它的命名中可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。无论何时，我们都可以调用 ReferenceQueue 的 poll() 方法来检查是否有它所关心的非强可及对象（即软引用对象）被回收。如果队列为空，将返回一个 null ,否则该方法返回队列中前面的一个 Reference 对象。那么从这里我们就可以知道利用这个方法来检查哪个 SoftReference 所软引用的对象已经被回收。同事，我们就可以把这些失去所软引用的对象的 SoftReference 对象清除掉。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_soft_refer</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Object soft_refer = <span class="keyword">new</span>  Object();  </span><br><span class="line">   ReferenceQueue queue = <span class="keyword">new</span>  ReferenceQueue();  </span><br><span class="line">   SoftReference obj_soft_refer=<span class="keyword">new</span> SoftReference(soft_refer,queue); </span><br><span class="line">   <span class="comment">// 此时 soft_refer 是一个强引用对象</span></span><br><span class="line">   soft_refer = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 此时 soft_refer 变为了一个软引用对象，当JVM内存不足时即会被回收掉</span></span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">     Object[] strong_refers = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers1 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     System.out.println(<span class="string">"-------&gt;"</span> + (obj_soft_refer.get()==<span class="keyword">null</span>)); <span class="comment">// false</span></span><br><span class="line">     Object[] strong_refers2 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers3 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">     Object[] strong_refers4 = <span class="keyword">new</span> Object[<span class="number">100000000</span>];</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">/** 结果为 true； </span></span><br><span class="line"><span class="comment">         如果前面不将 soft_refer = null; 则结果为false,因为此时 soft_refer 为强引用；</span></span><br><span class="line"><span class="comment">         否则即为true，这是由于前面发生了OOM而soft_refer被回收了； **/</span></span><br><span class="line">     System.out.println(<span class="string">"-------&gt;"</span> + (obj_soft_refer.get()==<span class="keyword">null</span>)); </span><br><span class="line">     <span class="keyword">while</span> ((obj_soft_refer = (Object) queue.poll()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">         <span class="comment">// 清除 obj_soft_refer</span></span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>弱引用（WeakReference）</font>如果一个对象只具有弱引用，那就类似于我们可有可无的工作台闲置物品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      WeakReference&lt;Object&gt; weak_refer_obj = <span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());  </span><br><span class="line">      System.out.println(weak_refer_obj.get() == <span class="keyword">null</span>);    <span class="comment">// 结果为 false </span></span><br><span class="line">      System.gc();<span class="comment">//通知GVM回收资源  </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">      System.out.println(weak_refer_obj.get()==<span class="keyword">null</span>);  <span class="comment">// 结果为 true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，我们上述代码中被弱引用关联的对象只有弱引用与之关联。但是如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Object weak_refer = <span class="keyword">new</span> Object();</span><br><span class="line">      WeakReference&lt;Object&gt; weak_refer_obj = <span class="keyword">new</span> WeakReference&lt;Object&gt;(weak_refer);  </span><br><span class="line">      System.out.println(weak_refer_obj.get() == <span class="keyword">null</span>);  <span class="comment">// 结果为 false</span></span><br><span class="line">      System.gc();<span class="comment">//通知GVM回收资源  </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">      System.out.println(weak_refer_obj.get()==<span class="keyword">null</span>);  <span class="comment">// 结果为false 主要原因是在方法体中第一行代码存在强引用关系；</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>虚引用（PhantomReference）</font> 和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用 java.lang.ref.PhantomReference 类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。但是要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的清除动作。<br>如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();  </span><br><span class="line">    PhantomReference&lt;Object&gt; phantom_refer = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(<span class="keyword">new</span> Object(), queue);  </span><br><span class="line">    System.out.println(phantom_refer.get()==<span class="keyword">null</span>); <span class="comment">// 结果为 true </span></span><br><span class="line">    ReferenceQueue&lt;Object&gt; queue_1 = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">    Object refer_obj = <span class="keyword">new</span> Object(); <span class="comment">// 这里存在强引用</span></span><br><span class="line">    PhantomReference&lt;Object&gt; phantom_refer_obj = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(refer_obj, queue);</span><br><span class="line">    System.out.println(phantom_refer_obj.get()==<span class="keyword">null</span>); <span class="comment">// 结果为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/Java%20%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/03/Java%20%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Java 应用性能调优实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2017-07-03 15:25:10" itemprop="dateCreated datePublished" datetime="2017-07-03T15:25:10+08:00">2017-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期由于项目上线由于数据量相对比较大，查询响应延迟比较明显，在Google解决办法的时候，偶然看到了这篇由三位牛人总结的性能调优技术文档，果断Mark了。转自【<a href="https://www.ibm.com/developerworks/cn/java/j-lo-performance-tuning-practice/index.html" target="_blank" rel="noopener"><font color=red>IBM Java technology</font></a>】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 应用性能优化是一个老生常谈的话题，典型的性能问题如页面响应慢、接口超时，服务器负载高、并发数低，数据库频繁死锁等。尤其是在“糙快猛”的互联网开发模式大行其道的今天，随着系统访问量的日益增加和代码的臃肿，各种性能问题开始纷至沓来。Java 应用性能的瓶颈点非常多，比如磁盘、内存、网络 I/O 等系统因素，Java 应用代码，JVM GC，数据库，缓存等。笔者根据个人经验，将 Java 性能优化分为 4 个层级：应用层、数据库层、框架层、JVM 层，如图 1 所示。<img title="图1. Java 性能优化分层模型" src="/uploads/2017-07-03-001.png"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每层优化难度逐级增加，涉及的知识和解决的问题也会不同。比如应用层需要理解代码逻辑，通过 Java 线程栈定位有问题代码行等；数据库层面需要分析 SQL、定位死锁等；框架层需要懂源代码，理解框架机制；JVM 层需要对 GC 的类型和工作机制有深入了解，对各种 JVM 参数作用了然于胸。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;围绕 Java 性能优化，有两种最基本的分析方法：现场分析法和事后分析法。现场分析法通过保留现场，再采用诊断工具分析定位。现场分析对线上影响较大，部分场景（特别是涉及到用户关键的在线业务时）不太合适。事后分析法需要尽可能多收集现场数据，然后立即恢复服务，同时针对收集的现场数据进行事后分析和复现。下面我们从性能诊断工具出发，分享搜狗商业平台在其中的一些案例与实践。</p>
<h2 id="性能诊断工具"><a href="#性能诊断工具" class="headerlink" title="性能诊断工具"></a>性能诊断工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性能诊断一种是针对已经确定有性能问题的系统和代码进行诊断，还有一种是对预上线系统提前性能测试，确定性能是否符合上线要求。本文主要针对前者，后者可以用各种性能压测工具（例如 JMeter）进行测试，不在本文讨论范围内。针对 Java 应用，性能诊断工具主要分为两层：OS 层面和 Java 应用层面（包括应用代码诊断和 GC 诊断）。</p>
<h3 id="OS-诊断"><a href="#OS-诊断" class="headerlink" title="OS 诊断"></a>OS 诊断</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OS 的诊断主要关注的是 CPU、Memory、I/O 三个方面。</p>
<h4 id="CPU-诊断"><a href="#CPU-诊断" class="headerlink" title="CPU 诊断"></a>CPU 诊断</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 CPU 主要关注平均负载（Load Average），CPU 使用率，上下文切换次数（Context Switch）。通过 top 命令可以查看系统平均负载和 CPU 使用率，图 2 为通过 top 命令查看某系统的状态。<img src="/uploads/2017-07-03-002.png" title="图 2.top 命令示例"/>平均负载有三个数字：63.66，58.39，57.18，分别表示过去 1 分钟、5 分钟、15 分钟机器的负载。按照经验，若数值小于 0.7*CPU 个数，则系统工作正常；若超过这个值，甚至达到 CPU 核数的四五倍，则系统的负载就明显偏高。图 2 中 15 分钟负载已经高达 57.18，1 分钟负载是 63.66（系统为 16 核），说明系统出现负载问题，且存在进一步升高趋势，需要定位具体原因了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过 vmstat 命令可以查看 CPU 的上下文切换次数，如图 3 所示：<img src="/uploads/2017-07-03-003.png" title="图 3.vmstat 命令示例"/>上下文切换次数发生的场景主要有如下几种：1）时间片用完，CPU 正常调度下一个任务；2）被其它优先级更高的任务抢占；3）执行任务碰到 I/O 阻塞，挂起当前任务，切换到下一个任务；4）用户代码主动挂起当前任务让出 CPU；5）多任务抢占资源，由于没有抢到被挂起；6）硬件中断。Java 线程上下文切换主要来自共享资源的竞争。一般单个对象加锁很少成为系统瓶颈，除非锁粒度过大。但在一个访问频度高，对多个对象连续加锁的代码块中就可能出现大量上下文切换，成为系统瓶颈。比如在我们系统中就曾出现 log4j 1.x 在较大并发下大量打印日志，出现频繁上下文切换，大量线程阻塞，导致系统吞吐量大降的情况，其相关代码如清单 1 所示，升级到 log4j 2.x 才解决这个问题。<br>清单 1. log4j 1.x 同步代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Category c = <span class="keyword">this</span>; c != <span class="keyword">null</span>; c=c.parent) &#123;</span><br><span class="line"> <span class="comment">// Protected against simultaneous call to addAppender, removeAppender,…</span></span><br><span class="line"> <span class="keyword">synchronized</span>(c) &#123;</span><br><span class="line"> <span class="keyword">if</span> (c.aai != <span class="keyword">null</span>) &#123;</span><br><span class="line"> write += c.aai.appendLoopAppenders(event);</span><br><span class="line"> &#125;</span><br><span class="line"> …</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从操作系统角度，内存关注应用进程是否足够，可以使用 free –m 命令查看内存的使用情况。通过 top 命令可以查看进程使用的虚拟内存 VIRT 和物理内存 RES，根据公式 VIRT = SWAP + RES 可以推算出具体应用使用的交换分区（Swap）情况，使用交换分区过大会影响 Java 应用性能，可以将 swappiness 值调到尽可能小。因为对于 Java 应用来说，占用太多交换分区可能会影响性能，毕竟磁盘性能比内存慢太多。</p>
<h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I/O 包括磁盘 I/O 和网络 I/O，一般情况下磁盘更容易出现 I/O 瓶颈。通过 iostat 可以查看磁盘的读写情况，通过 CPU 的 I/O wait 可以看出磁盘 I/O 是否正常。如果磁盘 I/O 一直处于很高的状态，说明磁盘太慢或故障，成为了性能瓶颈，需要进行应用优化或者磁盘更换。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了常用的 top、 ps、vmstat、iostat 等命令，还有其他 Linux 工具可以诊断系统问题，如 mpstat、tcpdump、netstat、pidstat、sar 等。Brendan 总结列出了 Linux 不同设备类型的性能诊断工具，如图 4 所示，可供参考。<img src="/uploads/2017-07-03-004.png" title="图 4.Linux 性能观测工具"/></p>
<h3 id="Java-应用诊断工具"><a href="#Java-应用诊断工具" class="headerlink" title="Java 应用诊断工具"></a>Java 应用诊断工具</h3><h4 id="应用代码诊断"><a href="#应用代码诊断" class="headerlink" title="应用代码诊断"></a>应用代码诊断</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应用代码性能问题是相对好解决的一类性能问题。通过一些应用层面监控报警，如果确定有问题的功能和代码，直接通过代码就可以定位；或者通过 top+jstack，找出有问题的线程栈，定位到问题线程的代码上，也可以发现问题。对于更复杂，逻辑更多的代码段，通过 Stopwatch 打印性能日志往往也可以定位大多数应用代码性能问题。<br>常用的 Java 应用诊断包括线程、堆栈、GC 等方面的诊断。</p>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jstack 命令通常配合 top 使用，通过 top -H -p pid 定位 Java 进程和线程，再利用 jstack -l pid 导出线程栈。由于线程栈是瞬态的，因此需要多次 dump，一般 3 次 dump，一般每次隔 5s 就行。将 top 定位的 Java 线程 pid 转成 16 进制，得到 Java 线程栈中的 nid，可以找到对应的问题线程栈。<img src="/uploads/2017-07-03-005.png" title="图 5. 通过 top –H -p 查看运行时间较长 Java 线程"/>如图 5 所示，其中的线程 24985 运行时间较长，可能存在问题，转成 16 进制后，通过 Java 线程栈找到对应线程 0x6199 的栈如下，从而定位问题点，如图 6 所示。<img src="/uploads/2017-07-03-006.png" title="图 6.jstack 查看线程堆栈" /></p>
<h4 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JProfiler 可对 CPU、堆、内存进行分析，功能强大，如图 7 所示。同时结合压测工具，可以对代码耗时采样统计。<img src="/uploads/2017-07-03-007.png" title="图 7. 通过 JProfiler 进行内存分析"/></p>
<h3 id="GC-诊断"><a href="#GC-诊断" class="headerlink" title="GC 诊断"></a>GC 诊断</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java GC 解决了程序员管理内存的风险，但 GC 引起的应用暂停成了另一个需要解决的问题。JDK 提供了一系列工具来定位 GC 问题，比较常用的有 jstat、jmap，还有第三方工具 MAT 等。</p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jstat 命令可打印 GC 详细信息，Young GC 和 Full GC 次数，堆信息等。其命令格式为jstat –gcxxx -t pid <interval> <count>，如图 8 所示。<img src="/uploads/2017-07-03-008.png" title="图 8.jstat 命令示例"/></p>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmap 打印 Java 进程堆信息 jmap –heap pid。通过 jmap –dump:file=xxx pid 可 dump 堆到文件，然后通过其它工具进一步分析其堆使用情况。</p>
<h4 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAT 是 Java 堆的分析利器，提供了直观的诊断报告，内置的 OQL 允许对堆进行类 SQL 查询，功能强大，outgoing reference 和 incoming reference 可以对对象引用追根溯源。<img src="/uploads/2017-07-03-009.png" title="图 9.MAT 示例"/>图 9 是 MAT 使用示例，MAT 有两列显示对象大小，分别是 Shallow size 和 Retained size，前者表示对象本身占用内存的大小，不包含其引用的对象，后者是对象自己及其直接或间接引用的对象的 Shallow size 之和，即该对象被回收后 GC 释放的内存大小，一般说来关注后者大小即可。对于有些大堆 (几十 G) 的 Java 应用，需要较大内存才能打开 MAT。通常本地开发机内存过小，是无法打开的，建议在线下服务器端安装图形环境和 MAT，远程打开查看。或者执行 mat 命令生成堆索引，拷贝索引到本地，不过这种方式看到的堆信息有限。<br>为了诊断 GC 问题，建议在 JVM 参数中加上-XX:+PrintGCDateStamps。常用的 GC 参数如图 10 所示。<img src="/uploads/2017-07-03-010.png" title="图 10. 常用 GC 参数"/>对于 Java 应用，通过 top+jstack+jmap+MAT 可以定位大多数应用和内存问题，可谓必备工具。有些时候，Java 应用诊断需要参考 OS 相关信息，可使用一些更全面的诊断工具，比如 Zabbix（整合了 OS 和 JVM 监控）等。在分布式环境中，分布式跟踪系统等基础设施也对应用性能诊断提供了有力支持。</p>
<h2 id="性能优化实践"><a href="#性能优化实践" class="headerlink" title="性能优化实践"></a>性能优化实践</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍了一些常用的性能诊断工具后，下面将结合我们在 Java 应用调优中的一些实践，从 JVM 层、应用代码层以及数据库层进行案例分享。</p>
<h3 id="JVM-调优：GC-之痛"><a href="#JVM-调优：GC-之痛" class="headerlink" title="JVM 调优：GC 之痛"></a>JVM 调优：GC 之痛</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搜狗商业平台某系统重构时选择 RMI 作为内部远程调用协议，系统上线后开始出现周期性的服务停止响应，暂停时间由数秒到数十秒不等。通过观察 GC 日志，发现服务自启动后每小时会出现一次 Full GC。由于系统堆设置较大，Full GC 一次暂停应用时间会较长，这对线上实时服务影响较大。经过分析，在重构前系统没有出现定期 Full GC 的情况，因此怀疑是 RMI 框架层面的问题。通过公开资料，发现 RMI 的 GDC（Distributed Garbage Collection，分布式垃圾收集）会启动守护线程定期执行 Full GC 来回收远程对象，清单 2 中展示了其守护线程代码。<br>清单 2.DGC 守护线程源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">     <span class="comment">//…</span></span><br><span class="line"> <span class="keyword">long</span> d = maxObjectInspectionAge();</span><br><span class="line"> <span class="keyword">if</span> (d &gt;= l) &#123;</span><br><span class="line">    System.gc(); </span><br><span class="line"> d = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//…</span></span><br><span class="line"> &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定位问题后解决起来就比较容易了。一种是通过增加-XX:+DisableExplicitGC 参数，直接禁用系统 GC 的显示调用，但对使用 NIO 的系统，会有堆外内存溢出的风险。另一种方式是通过调大 -Dsun.rmi.dgc.server.gcInterval 和-Dsun.rmi.dgc.client.gcInterval 参数，增加 Full GC 间隔，同时增加参数-XX:+ExplicitGCInvokesConcurrent，将一次完全 Stop-The-World 的 Full GC 调整为一次并发 GC 周期，减少应用暂停时间，同时对 NIO 应用也不会造成影响。从图 11 可知，调整之后的 Full GC 次数 在 3 月之后明显减少。<img src="/uploads/2017-07-03-011.png" title="图 11.Full GC 监控统计"/>GC 调优对高并发大数据量交互的应用还是很有必要的，尤其是默认 JVM 参数通常不满足业务需求，需要进行专门调优。GC 日志的解读有很多公开的资料，本文不再赘述。GC 调优目标基本有三个思路：降低 GC 频率，可以通过增大堆空间，减少不必要对象生成；降低 GC 暂停时间，可以通过减少堆空间，使用 CMS GC 算法实现；避免 Full GC，调整 CMS 触发比例，避免 Promotion Failure 和 Concurrent mode failure（老年代分配更多空间，增加 GC 线程数加快回收速度），减少大对象生成等。</p>
<h3 id="应用层调优：嗅到代码的坏味道"><a href="#应用层调优：嗅到代码的坏味道" class="headerlink" title="应用层调优：嗅到代码的坏味道"></a>应用层调优：嗅到代码的坏味道</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从应用层代码调优入手，剖析代码效率下降的根源，无疑是提高 Java 应用性能的很好的手段之一。某商业广告系统（采用 Nginx 进行负载均衡）某次日常上线后，其中有几台机器负载急剧升高，CPU 使用率迅速打满。我们对线上进行了紧急回滚，并通过 jmap 和 jstack 对其中某台服务器的现场进行保存。<img src="/uploads/2017-07-03-012.png" title="图 12. 通过 MAT 分析堆栈现场"/>堆栈现场如图 12 所示，根据 MAT 对 dump 数据的分析，发现最多的内存对象为 byte[] 和 java.util.HashMap $Entry，且 java.util.HashMap $Entry 对象存在循环引用。初步定位在该 HashMap 的 put 过程中有可能出现了死循环问题（图中 java.util.HashMap $Entry 0x2add6d992cb8 和 0x2add6d992ce8 的 next 引用形成循环）。查阅相关文档定位这属于典型的并发使用的场景错误 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457" target="_blank" rel="noopener">走你</a> ，简要的说就是 HashMap 本身并不具备多线程并发的特性，在多个线程同时 put 操作的情况下，内部数组进行扩容时会导致 HashMap 的内部链表形成环形结构，从而出现死循环。<br>针对此次上线，最大的改动在于通过内存缓存网站数据来提升系统性能，同时使用了懒加载机制，如清单 3 所示。<br>清单 3. 网站数据懒加载代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, UnionDomain&gt; domainMap = <span class="keyword">new</span> HashMap&lt;Long, UnionDomain&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isResetDomains</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(domainMap)) &#123;</span><br><span class="line">            <span class="comment">// 从远端 http 接口获取网站详情</span></span><br><span class="line">            List&lt;UnionDomain&gt; newDomains = unionDomainHttpClient</span><br><span class="line">                    .queryAllUnionDomain();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(domainMap)) &#123;</span><br><span class="line">                domainMap = <span class="keyword">new</span> HashMap&lt;Long, UnionDomain&gt;();</span><br><span class="line">                <span class="keyword">for</span> (UnionDomain domain : newDomains) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        domainMap.put(domain.getSubdomainId(), domain);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到此处的 domainMap 为静态共享资源，它是 HashMap 类型，在多线程情况下会导致其内部链表形成环形结构，出现死循环。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对前端 Nginx 的连接和访问日志可以看到，由于在系统重启后 Nginx 积攒了大量的用户请求，在 Resin 容器启动，大量用户请求涌入应用系统，多个用户同时进行网站数据的请求和初始化工作，导致 HashMap 出现并发问题。在定位故障原因后解决方法则比较简单，主要的解决方法有：<br>（1）采用 ConcurrentHashMap 或者同步块的方式解决上述并发问题;<br/>（2）在系统启动前完成网站缓存加载，去除懒加载等；<br/>（3）采用分布式缓存替换本地缓存等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于坏代码的定位，除了常规意义上的代码审查外，借助诸如 MAT 之类的工具也可以在一定程度对系统性能瓶颈点进行快速定位。但是一些与特定场景绑定或者业务数据绑定的情况，却需要辅助代码走查、性能检测工具、数据模拟甚至线上引流等方式才能最终确认性能问题的出处。以下是我们总结的一些坏代码可能的一些特征，供大家参考：<br>（1）代码可读性差，无基本编程规范；<br/>（2）对象生成过多或生成大对象，内存泄露等；<br/>（3）IO 流操作过多，或者忘记关闭；<br/>（4）数据库操作过多，事务过长;<br/>（5）同步使用的场景错误;<br/>（6）循环迭代耗时操作等。</p>
<h3 id="数据库层调优：死锁噩梦"><a href="#数据库层调优：死锁噩梦" class="headerlink" title="数据库层调优：死锁噩梦"></a>数据库层调优：死锁噩梦</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于大部分 Java 应用来说，与数据库进行交互的场景非常普遍，尤其是 OLTP 这种对于数据一致性要求较高的应用，数据库的性能会直接影响到整个应用的性能。搜狗商业平台系统作为广告主的广告发布和投放平台，对其物料的实时性和一致性都有极高的要求，我们在关系型数据库优化方面也积累了一定的经验。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于广告物料库来说，较高的操作频繁度（特别是通过批量物料工具操作）很极易造成数据库的死锁情况发生，其中一个比较典型的场景是广告物料调价。客户往往会频繁的对物料的出价进行调整，从而间接给数据库系统造成较大的负载压力，也加剧了死锁发生的可能性。下面以搜狗商业平台某广告系统广告物料调价的案例进行说明。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某商业广告系统某天访问量突增，造成系统负载升高以及数据库频繁死锁，死锁语句如图 13 所示。<img src="/uploads/2017-07-03-013.png" title="图 13. 死锁语句" />其中，groupdomain 表上索引为 idx_groupdomain_accountid (accountid)，idx_groupdomain_groupid(groupid)，primary(groupdomainid) 三个单索引结构，采用 Mysql innodb 引擎。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此场景发生在更新组出价时，场景中存在着组、组行业（groupindus 表）和组网站（groupdomain 表）。当更新组出价时，若组行业出价使用组出价（通过 isusegroupprice 标示，若为 1 则使用组出价）。同时若组网站出价使用组行业出价（通过 isuseindusprice 标示，若为 1 则使用组行业出价）时，也需要同时更新其组网站出价。由于每个组下面最大可以有 3000 个网站，因此在更新组出价时会长时间的对相关记录进行锁定。从上面发生死锁的问题可以看到，事务 1 和事务 2 均选择了 idx_groupdomain_accountid 的单列索引。根据 Mysql innodb 引擎加锁的特点，在一次事务中只会选择一个索引使用，而且如果一旦使用二级索引进行加锁后，会尝试将主键索引进行加锁。进一步分析可知事务 1 在请求事务 2 持有的<code>idx_groupdomain_accountid</code>二级索引加锁（加锁范围“space id 5726 page no 8658 n bits 824 index”），但是事务 2 已获得该二级索引 (“space id 5726 page no 8658 n bits 824 index”) 上所加的锁，在等待请求锁定主键索引 PRIMARY 索引上的锁。由于事务 2 等待执行时间过长或长时间不释放锁，导致事务 1 最终发生回滚。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对当天访问日志跟踪可以看到，当天有客户通过脚本方式发起大量的修改推广组出价的操作，导致有大量事务在循环等待前一个事务释放锁定的主键 PRIMARY 索引。该问题的根源实际上在于 Mysql innodb 引擎对于索引利用有限，在 Oracle 数据库中此问题并不突出。解决的方式自然是希望单个事务锁定的记录数越少越好，这样产生死锁的概率也会大大降低。最终使用了（accountid, groupid）的复合索引，缩小了单个事务锁定的记录条数，也实现了不同计划下的推广组数据记录的隔离，从而减少该类死锁的发生几率。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说，对于数据库层的调优我们基本上会从以下几个方面出发：<br>（1）在 SQL 语句层面进行优化：慢 SQL 分析、索引分析和调优、事务拆分等；<br/>（2）在数据库配置层面进行优化：比如字段设计、调整缓存大小、磁盘 I/O 等数据库参数优化、数据碎片整理等；<br/>（3）从数据库结构层面进行优化：考虑数据库的垂直拆分和水平拆分等；<br/>（4）选择合适的数据库引擎或者类型适应不同场景，比如考虑引入 NoSQL 等。</p>
<h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性能调优同样遵循 2-8 原则，80%的性能问题是由 20%的代码产生的，因此优化关键代码事半功倍。同时，对性能的优化要做到按需优化，过度优化可能引入更多问题。对于 Java 性能优化，不仅要理解系统架构、应用代码，同样需要关注 JVM 层甚至操作系统底层。总结起来主要可以从以下几点进行考虑：<br>1）基础性能的调优<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的基础性能指的是硬件层级或者操作系统层级的升级优化，比如网络调优，操作系统版本升级，硬件设备优化等。比如 F5 的使用和 SDD 硬盘的引入，包括新版本 Linux 在 NIO 方面的升级，都可以极大的促进应用的性能提升；<br>2）数据库性能优化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包括常见的事务拆分，索引调优，SQL 优化，NoSQL 引入等，比如在事务拆分时引入异步化处理，最终达到一致性等做法的引入，包括在针对具体场景引入的各类 NoSQL 数据库，都可以大大缓解传统数据库在高并发下的不足；<br>3）应用架构优化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入一些新的计算或者存储框架，利用新特性解决原有集群计算性能瓶颈等；或者引入分布式策略，在计算和存储进行水平化，包括提前计算预处理等，利用典型的空间换时间的做法等；都可以在一定程度上降低系统负载；<br>4）业务层面的优化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;技术并不是提升系统性能的唯一手段，在很多出现性能问题的场景中，其实可以看到很大一部分都是因为特殊的业务场景引起的，如果能在业务上进行规避或者调整，其实往往是最有效的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/20/Java%20%E9%9B%86%E5%90%88%E7%B1%BB%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93-%E8%BD%AC%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/03/20/Java%20%E9%9B%86%E5%90%88%E7%B1%BB%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93-%E8%BD%AC%E8%BD%BD/" class="post-title-link" itemprop="url">Java 集合类操作优化经验总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2016-03-20 20:37:20" itemprop="dateCreated datePublished" datetime="2016-03-20T20:37:20+08:00">2016-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕业到现在已经有小俩年的时间了，在这俩年中一直都是围绕着 JavaWeb 相关的技术进行 JavaWeb 系统开发（Java，JSP，JavaScript，SQL 等）。学到的知识相对于学校中学习的知识要既丰富又有深度……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本着站在巨人的肩膀上成长的想法，经常 Google 或 Baidu 一些有深度或相对丰富的技术博客来膜拜学习。今天看到了这位牛人对于Java 集合相关知识的总结，觉着是我的菜 +_+ ，很合胃口就转来了。转载自【<a href="https://www.ibm.com/developerworks/cn/java/j-lo-set-operation/index.html" target="_blank" rel="noopener"><font color=red>IBM Java technology</font></a>】</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的项目开发中会有很多的对象，如何高效、方便地管理对象，成为影响程序性能与可维护性的重要环节。Java 提供了集合框架来解决此类问题，线性表、链表、哈希表等是常用的数据结构，在进行 Java 开发时，JDK 已经为我们提供了一系列相应的类来实现基本的数据结构，所有类都在 java.util 这个包里，图1. 描述了集合类的关系。<img src="/uploads/2016-03-20-001.png" title="图 1.集合类之间关系"/>本文讲的就是集合框架的使用经验总结，注意，本文所有代码基于 JDK7。</p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素（Elements）。一些 Collection 允许相同的元素、支持对元素进行排序，另一些则不行。JDK 不提供直接继承自 Collection 的类，JDK 提供的类都是继承自 Collection 的子接口，如 List 和 Set。所有实现 Collection 接口的类都必须提供两个标准的构造函数，无参数的构造函数用于创建一个空的 Collection，有一个 Collection 参数的构造函数用于创建一个新的 Collection，这个新的 Collection 与传入的 Collection 有相同的元素，后一个构造函数允许用户复制一个 Collection。<br><font color=red>如何遍历 Collection 中的每一个元素？</font><br>不论 Collection 的实际类型如何，它都支持一个 iterator() 的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问 Collection 中每一个元素。典型的用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = collection.iterator(); <span class="comment">// 获得一个迭代子</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Object obj = it.next(); <span class="comment">// 得到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collection 接口派生的两个接口是 List 和 Set。<br>Collection 接口提供的主要方法：<br>1· boolean add(Object o) 添加对象到集合；<br>2· boolean remove(Object o) 删除指定的对象；<br>3· int size() 返回当前集合中元素的数量；<br>4· boolean contains(Object o) 查找集合中是否有指定的对象；<br>5· boolean isEmpty() 判断集合是否为空；<br>6· Iterator iterator() 返回一个迭代器；<br>7· boolean containsAll(Collection c) 查找集合中是否有集合 C 中的元素；<br>8· boolean addAll(Collection c) 将集合 C 中所有的元素添加给该集合；<br>9· void clear() 删除集合中所有元素；<br>10· void removeAll(Collection c) 从集合中删除 C 集合中也有的元素；<br>11· void retainAll(Collection c) 从集合中删除集合 C 中不包含的元素；</p>
<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List 是有序的 Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于 Java 的数组。和下文要提到的 Set 不同，List 允许有相同的元素。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了具有 Collection 接口必备的 iterator() 方法外，List 还提供一个 listIterator() 方法，返回一个 ListIterator 接口。和标准的 Iterator 接口相比，ListIterator 多了一些 add() 之类的方法，允许添加、删除、设定元素、向前或向后遍历等功能。实现 List 接口的常用类有 LinkedList，ArrayList，Vector 和 Stack 等。<br>List 接口提供的主要方法：<br>1· void add(int index,Object element) 在指定位置上添加一个对象；<br>2· boolean addAll(int index,Collection c) 将集合 C 的元素添加到指定的位置；<br>3· Object get(int index) 返回 List 中指定位置的元素；<br>4· int indexOf(Object o) 返回第一个出现元素 O 的位置；<br>5· Object removeint(int index) 删除指定位置的元素；<br>6· Object set(int index,Object element) 用元素 element 取代位置 index 上的元素, 返回被取代的元素；</p>
<h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map 没有继承 Collection 接口。Map 提供 Key 到 Value 的映射，一个 Map 中不能包含相同的 Key，每个 Key 只能映射一个 Value。Map 接口提供 3 种集合的视图，Map 的内容可以被当作一组 Key 集合，一组 Value 集合，或者一组 Key-Value 映射。<br>Map 提供的主要方法：<br>1· boolean equals(Object o) 比较对象；<br>2· boolean remove(Object o) 删除一个对象；<br>3· put(Object key,Object value) 添加 key 和 value。</p>
<h3 id="RandomAccess-接口"><a href="#RandomAccess-接口" class="headerlink" title="RandomAccess 接口"></a>RandomAccess 接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RandomAccess 接口是一个标志接口，本身并没有提供任何方法，任务凡是通过调用 RandomAccess 接口的对象都可以认为是支持快速随机访问的对象。此接口的主要目的是标识那些可支持快速随机访问的 List 实现。任何一个基于数组的 List 实现都实现了 RaodomAccess 接口，而基于链表的实现则都没有。因为只有数组能够进行快速的随机访问，而对链表的随机访问需要进行链表的遍历。因此，此接口的好处是，可以在应用程序中知道正在处理的 List 对象是否可以进行快速随机访问，从而针对不同的 List 进行不同的操作，以提高程序的性能。</p>
<h2 id="集合类介绍"><a href="#集合类介绍" class="headerlink" title="集合类介绍"></a>集合类介绍</h2><h3 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedList 实现了 List 接口，允许 Null 元素。此外 LinkedList 提供额外的 Get、Remove、Insert 等方法在 LinkedList 的首部或尾部操作数据。这些操作使得 LinkedList 可被用作堆栈（Stack）、队列（Queue）或双向队列（Deque）。请注意 LinkedList 没有同步方法，它不是线程同步的，即如果多个线程同时访问一个 List，则必须自己实现访问同步。一种解决方法是在创建 List 时构造一个同步的 List，方法如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList 实现了可变大小的数组。它允许所有元素，包括 Null。Size、IsEmpty、Get、Set 等方法的运行时间为常数，但是 Add 方法开销为分摊的常数，添加 N 个元素需要 O(N) 的时间，其他的方法运行时间为线性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个 ArrayList 实例都有一个容量（Capacity），用于存储元素的数组的大小，这个容量可随着不断添加新元素而自动增加。当需要插入大量元素时，在插入前可以调用 ensureCapacity 方法来增加 ArrayList 的容量以提高插入效率。和 LinkedList 一样，ArrayList 也是线程非同步的（unsynchronized）。<br>ArrayList 提供的主要方法：<br>1· Boolean add(Object o) 将指定元素添加到列表的末尾；<br>2· Boolean add(int index,Object element) 在列表中指定位置加入指定元素；<br>3· Boolean addAll(Collection c) 将指定集合添加到列表末尾；<br>4· Boolean addAll(int index,Collection c) 在列表中指定位置加入指定集合；<br>5· Boolean clear() 删除列表中所有元素；<br>6· Boolean clone() 返回该列表实例的一个拷贝；<br>7· Boolean contains(Object o) 判断列表中是否包含元素；<br>8· Boolean ensureCapacity(int m) 增加列表的容量，如果必须，该列表能够容纳 m 个元素；<br>9· Object get(int index) 返回列表中指定位置的元素；<br>10· Int indexOf(Object elem) 在列表中查找指定元素的下标；<br>11· Int size() 返回当前列表的元素个数；</p>
<h3 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector 非常类似于 ArrayList，区别是 Vector 是线程同步的。由 Vector 创建的 Iterator，虽然和 ArrayList 创建的 Iterator 是同一接口，但是，因为 Vector 是同步的，当一个 Iterator 被创建而且正在被使用，另一个线程改变了 Vector 的状态（例如，添加或删除了一些元素），这时调用 Iterator 的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p>
<h3 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack 继承自 Vector，实现了一个后进先出的堆栈。Stack 提供 5 个额外的方法使得 Vector 得以被当作堆栈使用。除了基本的 Push 和 Pop 方法，还有 Peek 方法得到栈顶的元素，Empty 方法测试堆栈是否为空，Search 方法检测一个元素在堆栈中的位置。注意，Stack 刚创建后是空栈。</p>
<h3 id="Set-类"><a href="#Set-类" class="headerlink" title="Set 类"></a>Set 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set 是一种不包含重复的元素的 Collection，即任意的两个元素 e1 和 e2 都有 e1.equals(e2)=false。Set 最多有一个 null 元素。很明显，Set 的构造函数有一个约束条件，传入的 Collection 参数不能包含重复的元素。请注意，必须小心操作可变对象（Mutable Object），如果一个 Set 中的可变元素改变了自身状态，这可能会导致一些问题。</p>
<h3 id="Hashtable-类"><a href="#Hashtable-类" class="headerlink" title="Hashtable 类"></a>Hashtable 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 继承 Map 接口，实现了一个基于 Key-Value 映射的哈希表。任何非空（non-null）的对象都可作为 Key 或者 Value。添加数据使用 Put(Key，Value)，取出数据使用 Get(Key)，这两个基本操作的时间开销为常数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 通过 Initial Capacity 和 Load Factor 两个参数调整性能。通常缺省的 Load Factor 0.75 较好地实现了时间和空间的均衡。增大 Load Factor 可以节省空间但相应的查找时间将增大，会影响像 Get 和 Put 这样的操作。使用 Hashtable 的简单示例，将 1、2、3 这三个数字放到 Hashtable 里面，他们的 Key 分别是”one”、”two”、”three”，代码如清单 2 所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hashtable numbers = <span class="keyword">new</span> Hashtable();</span><br><span class="line">numbers.put(“one”, <span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">numbers.put(“two”, <span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">numbers.put(“three”, <span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>如果我们需要取出一个数，比如 2，可以用相应的 key 来取出，代码如清单 3 所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = (Integer)numbers.get(“two”); </span><br><span class="line">System.out.println(“two =”+ n);</span><br></pre></td></tr></table></figure>
<p>由于作为 Key 的对象将通过计算其散列函数来确定与之对应的 Value 的位置，因此任何作为 key 的对象都必须实现 HashCode 和 Equals 方法。HashCode 和 Equals 方法继承自根类 Object，如果你用自定义的类当作 Key 的话，要相当小心，按照散列函数的定义，如果两个对象相同，即 obj1.equals(obj2)=true，则它们的 HashCode 必须相同，但如果两个对象不同，则它们的 HashCode 不一定不同，如果两个不同对象的 HashCode 相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的 HashCode() 方法，能加快哈希表的操作。<br>如果相同的对象有不同的 HashCode，对哈希表的操作会出现意想不到的结果（期待的 Get 方法返回 Null），要避免这种问题，最好同时复写 Equals 方法和 HashCode 方法，而不要只写其中一个。</p>
<h3 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap 类"></a>HashMap 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 和 Hashtable 类似，不同之处在于 HashMap 是线程非同步的，并且允许 Null，即 Null Value 和 Null Key。但是将 HashMap 视为 Collection 时（values() 方法可返回 Collection），其迭代子操作时间开销和 HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将 HashMap 的初始化容量设得过高，或者 Load Factor 参数设置过低。</p>
<h3 id="WeakHashMap-类"><a href="#WeakHashMap-类" class="headerlink" title="WeakHashMap 类"></a>WeakHashMap 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 是一种改进的 HashMap，它对 Key 实行“弱引用”，如果一个 Key 不再被外部所引用，那么该 Key 可以被 GC 回收。</p>
<h2 id="集合类实践"><a href="#集合类实践" class="headerlink" title="集合类实践"></a>集合类实践</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList、Vector、LinkedList 均来自 AbstractList 的实现，而 AbstractList 直接实现了 List 接口，并扩展自 AbstarctCollection。ArrayList 和 Vector 使用了数组实现，ArrayList 没有对任何一个方法提供线程同步，因此不是线程安全的，Vector 中绝大部分方法都做了线程同步，是一种线程安全的实现。LinkedList 使用了循环双向链表数据结构，由一系列表项连接而成，一个表项总是包含 3 个部分，元素内容、前驱表项和后驱表项。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 ArrayList 对容量的需求超过当前数组的大小时，需要进行扩容。扩容过程中，会进行大量的数组复制操作，而数组复制时，最终将调用 System.arraycopy() 方法。LinkedList 由于使用了链表的结构，因此不需要维护容量的大小，然而每次的元素增加都需要新建一个 Entry 对象，并进行更多的赋值操作，在频繁的系统调用下，对性能会产生一定的影响，在不间断地生成新的对象还是占用了一定的资源。而因为数组的连续性，因此总是在尾端增加元素时，只有在空间不足时才产生数组扩容和数组复制。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList 是基于数组实现的，而数组是一块连续的内存空间，如果在数组的任意位置插入元素，必然导致在该位置后的所有元素需要重新排列，因此其效率较差，尽可能将数据插入到尾部。LinkedList 不会因为插入数据导致性能下降。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList 的每一次有效的元素删除操作后都要进行数组的重组，并且删除的元素位置越靠前，数组重组时的开销越大，要删除的元素位置越靠后，开销越小。LinkedList 要移除中间的数据需要便利完半个 List。<br> ArrayList 和 LinkedList 使用示例代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListandLinkedList</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000000</span>;i++)&#123;</span><br><span class="line"> list.add(obj);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line">  </span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> LinkedList list1 = <span class="keyword">new</span> LinkedList();</span><br><span class="line"> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000000</span>;i++)&#123;</span><br><span class="line"> list1.add(obj1);</span><br><span class="line"> &#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line">  </span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"> list.add(<span class="number">0</span>,obj2);</span><br><span class="line"> &#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line">  </span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> Object obj3 = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"> list1.add(obj1);</span><br><span class="line"> &#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line">  </span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> list.remove(<span class="number">0</span>);</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line">  </span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> list1.remove(<span class="number">250000</span>);</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 执行结果如下图：<img src="/uploads/2017-03-20-001.png" title="上述代码运行结果图">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是将 Key 做 Hash 算法，然后将 Hash 值映射到内存地址，直接取得 Key 所对应的数据。在 HashMap 中，底层数据结构使用的是数组，所谓的内存地址即数组的下标索引。HashMap 的高性能需要保证以下几点：<br>1· Hash 算法必须是高效的；<br>2· Hash 值到内存地址 (数组索引) 的算法是快速的；<br>3· 根据内存地址 (数组索引) 可以直接取得对应的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 实际上是一个链表的数组。前面已经介绍过，基于 HashMap 的链表方式实现机制，只要 HashCode() 和 Hash() 方法实现得足够好，能够尽可能地减少冲突的产生，那么对 HashMap 的操作几乎等价于对数组的随机访问操作，具有很好的性能。但是，如果 HashCode() 或者 Hash() 方法实现较差，在大量冲突产生的情况下，HashMap 事实上就退化为几个链表，对 HashMap 的操作等价于遍历链表，此时性能很差。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 的一个功能缺点是它的无序性，被存入到 HashMap 中的元素，在遍历 HashMap 时，其输出是无序的。如果希望元素保持输入的顺序，可以使用 LinkedHashMap 替代。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap 继承自 HashMap，具有高效性，同时在 HashMap 的基础上，又在内部增加了一个链表，用以存放元素的顺序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 通过 hash 算法可以最快速地进行 Put() 和 Get() 操作。TreeMap 则提供了一种完全不同的 Map 实现。从功能上讲，TreeMap 有着比 HashMap 更为强大的功能，它实现了 SortedMap 接口，这意味着它可以对元素进行排序。TreeMap 的性能略微低于 HashMap。如果在开发中需要对元素进行排序，那么使用 HashMap 便无法实现这种功能，使用 TreeMap 的迭代输出将会以元素顺序进行。LinkedHashMap 是基于元素进入集合的顺序或者被访问的先后顺序排序，TreeMap 则是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap 是根据元素增加或者访问的先后顺序进行排序，而 TreeMap 则根据元素的 Key 进行排序。<br>清单 6 所示代码演示了使用 TreeMap 实现业务逻辑的排序，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//告诉 TreeMap 如何排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span>(o.score&lt;<span class="keyword">this</span>.score)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(o.score&gt;<span class="keyword">this</span>.score)&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">"name:"</span>);</span><br><span class="line">sb.append(name);</span><br><span class="line">sb.append(<span class="string">" "</span>);</span><br><span class="line">sb.append(<span class="string">"score:"</span>);</span><br><span class="line">sb.append(score);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">TreeMap map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"1"</span>,<span class="number">100</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"2"</span>,<span class="number">99</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">"3"</span>,<span class="number">97</span>);</span><br><span class="line">Student s4 = <span class="keyword">new</span> Student(<span class="string">"4"</span>,<span class="number">91</span>);</span><br><span class="line">map.put(s1, <span class="keyword">new</span> StudentDetailInfo(s1));</span><br><span class="line">map.put(s2, <span class="keyword">new</span> StudentDetailInfo(s2));</span><br><span class="line">map.put(s3, <span class="keyword">new</span> StudentDetailInfo(s3));</span><br><span class="line">map.put(s4, <span class="keyword">new</span> StudentDetailInfo(s4));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印分数位于 S4 和 S2 之间的人</span></span><br><span class="line">Map map1=((TreeMap)map).subMap(s4, s2);</span><br><span class="line"><span class="keyword">for</span>(Iterator iterator=map1.keySet().iterator();iterator.hasNext();)&#123;</span><br><span class="line">Student key = (Student)iterator.next();</span><br><span class="line">System.out.println(key+<span class="string">"-&gt;"</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"subMap end"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印分数比 s1 低的人</span></span><br><span class="line">map1=((TreeMap)map).headMap(s1);</span><br><span class="line"><span class="keyword">for</span>(Iterator iterator=map1.keySet().iterator();iterator.hasNext();)&#123;</span><br><span class="line">Student key = (Student)iterator.next();</span><br><span class="line">System.out.println(key+<span class="string">"-&gt;"</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"subMap end"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印分数比 s1 高的人</span></span><br><span class="line">map1=((TreeMap)map).tailMap(s1);</span><br><span class="line"><span class="keyword">for</span>(Iterator iterator=map1.keySet().iterator();iterator.hasNext();)&#123;</span><br><span class="line">Student key = (Student)iterator.next();</span><br><span class="line">System.out.println(key+<span class="string">"-&gt;"</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"subMap end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentDetailInfo</span></span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentDetailInfo</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.name + <span class="string">"'s detail information"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上示例代码运行结果如下：<img src="/uploads/2017-03-20-002.png" title="上述示例代码运行结果图">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 特点是当除了自身有对 Key 的引用外，如果此 Key 没有其他引用，那么此 Map 会自动丢弃该值。如清单 8 所示代码声明了两个 Map 对象，一个是 HashMap，一个是 WeakHashMap，同时向两个 map 中放入 A、B 两个对象，当 HashMap 删除 A，并且 A、B 都指向 Null 时，WeakHashMap 中的 A 将自动被回收掉。出现这个状况的原因是，对于 A 对象而言，当 HashMap 删除并且将 A 指向 Null 后，除了 WeakHashMap 中还保存 A 外已经没有指向 A 的指针了，所以 WeakHashMap 会自动舍弃掉 a，而对于 B 对象虽然指向了 null，但 HashMap 中还有指向 B 的指针，所以 WeakHashMap 将会保留 B 对象。<br>WeakHashMap 示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap; </span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"> String a = <span class="keyword">new</span> String(<span class="string">"a"</span>); </span><br><span class="line"> String b = <span class="keyword">new</span> String(<span class="string">"b"</span>); </span><br><span class="line"> Map weakmap = <span class="keyword">new</span> WeakHashMap(); </span><br><span class="line"> Map map = <span class="keyword">new</span> HashMap(); </span><br><span class="line"> map.put(a, <span class="string">"aaa"</span>); </span><br><span class="line"> map.put(b, <span class="string">"bbb"</span>);</span><br><span class="line"> weakmap.put(a, <span class="string">"aaa"</span>); </span><br><span class="line"> weakmap.put(b, <span class="string">"bbb"</span>);</span><br><span class="line"> map.remove(a);</span><br><span class="line"> a=<span class="keyword">null</span>; </span><br><span class="line"> b=<span class="keyword">null</span>;</span><br><span class="line"> System.gc(); </span><br><span class="line"> Iterator i = map.entrySet().iterator(); </span><br><span class="line"> <span class="keyword">while</span> (i.hasNext()) &#123; </span><br><span class="line"> Map.Entry en = (Map.Entry)i.next(); </span><br><span class="line"> System.out.println(<span class="string">"map:"</span>+en.getKey()+<span class="string">":"</span>+en.getValue()); </span><br><span class="line"> &#125; </span><br><span class="line"> Iterator j = weakmap.entrySet().iterator(); </span><br><span class="line"> <span class="keyword">while</span> (j.hasNext()) &#123; </span><br><span class="line"> Map.Entry en = (Map.Entry)j.next(); </span><br><span class="line"> System.out.println(<span class="string">"weakmap:"</span>+en.getKey()+<span class="string">":"</span>+en.getValue()); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：<img src="/uploads/2017-03-20-003.png" title="WeakHashMap 示例运行结果图"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 主要通过 expungeStaleEntries 这个函数来实现移除其内部不用的条目，从而达到自动释放内存的目的。基本上只要对 WeakHashMap 的内容进行访问就会调用这个函数，从而达到清除其内部不再为外部引用的条目。但是如果预先生成了 WeakHashMap，而在 GC 以前又不曾访问该 WeakHashMap, 那不是就不能释放内存了吗？如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> List&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;&gt; maps = <span class="keyword">new</span> ArrayList&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt; d = <span class="keyword">new</span> WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;();</span><br><span class="line"> d.put(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>][<span class="number">1000</span>], <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>][<span class="number">1000</span>]);</span><br><span class="line"> maps.add(d);</span><br><span class="line"> System.gc();</span><br><span class="line"> System.err.println(i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不改变任何 JVM 参数的情况运行清单 10 所示代码，由于 Java 默认内存是 64M，抛出内存溢出了错误。<br>上述示例运行结果如下：<img src="/uploads/2017-03-20-004.png" title="上述示例运行结果图"/>果不其然，WeakHashMap 这个时候并没有自动帮我们释放不用的内存。清单 12 所示代码不会出现内存溢出问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest2</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> List&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;&gt; maps = <span class="keyword">new</span> ArrayList&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt; d = <span class="keyword">new</span> WeakHashMap&lt;<span class="keyword">byte</span>[][], <span class="keyword">byte</span>[][]&gt;();</span><br><span class="line"> d.put(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>][<span class="number">1000</span>], <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>][<span class="number">1000</span>]);</span><br><span class="line"> maps.add(d);</span><br><span class="line"> System.gc();</span><br><span class="line"> System.err.println(i);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"> System.err.println(j + <span class="string">" size"</span> + maps.get(j).size());</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果发现这次测试输出正常, 不再出现内存溢出问题。<br>总的来说，WeakHashMap 并不是你什么也干它就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象。<br>WeakHashMap 实现弱引用，是因为它的 Entry&lt;K,V&gt;是继承自 WeakReference<K>的，<br>在 WeakHashMap$Entry&lt;K,V&gt;的类定义及构造函数里面如清单 13 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">K</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="title">Entry</span>(<span class="title">K</span> <span class="title">key</span>, <span class="title">V</span> <span class="title">value</span>, <span class="title">ReferenceQueue</span>&lt;<span class="title">K</span>&gt; <span class="title">queue</span>,<span class="title">int</span> <span class="title">hash</span>, <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="title">next</span>) </span>&#123; </span><br><span class="line"><span class="keyword">super</span>(key, queue); </span><br><span class="line"><span class="keyword">this</span>.value = value; </span><br><span class="line"><span class="keyword">this</span>.hash = hash; </span><br><span class="line"><span class="keyword">this</span>.next = next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意它构造父类的语句：“super(key, queue);”，传入的是 Key，因此 Key 才是进行弱引用的，Value 是直接强引用关联在 this.value 之中。在 System.gc() 时，Key 中的 Byte 数组进行了回收，而 Value 依然保持 (Value 被强关联到 Entry 上，Entry 又关联在 Map 中，Map 关联在 ArrayList 中)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For 循环中每次都 New 一个新的 WeakHashMap，在 Put 操作后，虽然 GC 将 WeakReference 的 Key 中的 Byte 数组回收了，并将事件通知到了 ReferenceQueue，但后续却没有相应的动作去触发 WeakHashMap 去处理 ReferenceQueue，所以 WeakReference 包装 Key 依然存在于 WeakHashMap 中，其对应的 value 也当然存在。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那 value 是何时被清除的呢? 对清单 10 和清单 11 两个示例程序进行分析可知，清单 11 的 maps.get(j).size() 触发了 Value 的回收，那又如何触发的呢？查看 WeakHashMap 源码可知,Size 方法调用了 expungeStaleEntries 方法，该方法对 JVM 要回收的的 Entry(Quene 中) 进行遍历，并将 Entry 的 Value 置空，回收了内存。所以效果是 Key 在 GC 的时候被清除，Value 在 Key 清除后访问 WeakHashMap 被清除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 类是线程不同步的，可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap, 每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。需要注意的是，WeakHashMap 中的值对象由普通的强引用保持。因此应该小心谨慎，确保值对象不会直接或间接地强引用其自身的键，因为这会阻止键的丢弃。注意，值对象可以通过 WeakHashMap 本身间接引用其对应的键，这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理此问题的一种方法是，在插入前将值自身包装在 WeakReferences 中，如：m.put(key, new WeakReference(value))，然后，分别用 get 进行解包，该类所有“collection 视图方法”返回的迭代器均是快速失败的，在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 Remove 或 Add 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。<br>注意，我们不能确保迭代器不失败，一般来说，存在不同步的并发修改时，不可能做出任何完全确定的保证。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合前面的介绍和实例代码，我们可以知道，如果涉及到堆栈、队列等操作，应该考虑用 List。对于需要快速插入、删除元素等操作，应该使用 LinkedList。如果需要快速随机访问元素，应该使用 ArrayList。如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高。如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为 Key 的对象要正确复写 Equals 和 HashCode 方法。尽量返回接口而非实际的类型，如返回 List 而非 ArrayList，这样如果以后需要将 ArrayList 换成 LinkedList 时，客户端代码不用改变，这就是针对抽象进行编程思想。<br>本文只是针对应用层面的分享，后续文章会针对具体源代码级别的实现进行深入介绍，也会对具体实现所基于的算法进行深入介绍，请有需要的读者关注后续文章。非常感谢作者的精心分享【<a href="https://www.ibm.com/developerworks/cn/java/j-lo-set-operation/index.html" target="_blank" rel="noopener"><font color=red>源地址</font></a>】</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/23/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8610/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/23/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8610/" class="post-title-link" itemprop="url">JavaScript基础知识整理<十>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-23 21:01:11" itemprop="dateCreated datePublished" datetime="2015-06-23T21:01:11+08:00">2015-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要学习总结关于 JavaScript 语言的面向对象的基础知识。在 ECMAScript 中，对象由特性（attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（method），否则该特性被看作对象的属性（property）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 ECMAScript 并没有正式的类。所以，ECMA-262 把对象定义描述为对象的配方。这是 ECMAScript 逻辑上的一种折中方案，因为对象定义实际上是对象自身。即使类并不真正存在，我们也把对象定义叫做类，因为大多数开发者对此术语更熟悉，而且从功能上说，两者是等价的。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><font color=red>对象</font>：ECMAScript 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。<br/><font color=red>类</font>：每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口，还要定义对象的内部工作。<br/><font color=red>实例</font>：程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。<br>面相对象的特点：<br>封装 - 可以把相关的信息（无论数据或方法）存储在对象中<br>继承 - 由另一个类（或多个类）得来类的属性和方法<br>多态 - 可以编写能以多种方法运行的函数或方法<br>聚集 - 可以把一个对象存储在另一个对象内</p>
<h3 id="对象属性或方法的绑定"><a href="#对象属性或方法的绑定" class="headerlink" title="对象属性或方法的绑定"></a>对象属性或方法的绑定</h3><p><font color=red>绑定（binding）</font>指把对象的接口与对象实例结合在一起的方法。<br/><font color=red>早绑定（early binding）</font>是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。<br/><font color=red>晚绑定（late binding）</font>指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">student.name=<span class="string">"MaxSoft"</span>;</span><br><span class="line">student.age=<span class="number">20</span>;</span><br><span class="line">student.sex=<span class="string">'男'</span>;</span><br><span class="line">student.height=<span class="number">168</span>;</span><br><span class="line">student.study = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"study"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red><b>注意</b></font>：ECMAScript 中的所有变量都采用晚绑定方法。</p>
<h3 id="对象回收"><a href="#对象回收" class="headerlink" title="对象回收"></a>对象回收</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言也拥有类似 Java 语言的垃圾回收机制，在我们编写程序代码可以不用手动回收无效的对象。当然，便于我们的程序的可维护性以及养成良好的编码习惯，建议在该释放销毁的时候尽量手动处理；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeer = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">employeer.id=<span class="string">"52028"</span>;</span><br><span class="line">employeer.name=<span class="string">"MaxSoft"</span>;</span><br><span class="line">employeer.mainjob=<span class="string">"Java programming "</span>;</span><br><span class="line">employeer.otherjob=<span class="string">"javascript"</span>;</span><br><span class="line"><span class="comment">//移除 otherjob</span></span><br><span class="line"><span class="keyword">delete</span> employeer.otherjob;</span><br><span class="line"><span class="built_in">console</span>.log(employeer.otherjob)</span><br><span class="line"><span class="comment">//销毁对象</span></span><br><span class="line">employeer = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(employeer.id);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/object_001.png'/>在上述示例中我们通过 delete 运算符移除了属性otherjob，后面我们对 employeer 进行了销毁处理；</p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 中，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。<br><font color=red><b>本地对象</b></font>：指独立于宿主环境的 ECMAScript 实现提供的对象；主要包括：Object, Function, Array, String, Boolean, Number, Date, RegExp, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError；<br/><font color=red><b>内置对象</b></font>：指由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。<br/><font color=red><b>宿主对象</b></font>：所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。</p>
<h2 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red><b>作用域</b></font>：指的是变量的适用范围。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。由于我们开发人员的习惯有以下几种方法来进行对私有变量和公有变量进行了区分的公约：<br>&nbsp;&nbsp;● 对象属性前后加下划线标识私有属性<br>&nbsp;&nbsp;● 对象属性前加下划线标识私有属性<br>&nbsp;&nbsp;● 对象属性前加私有变量标识，例如：”obj.private_id”等<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj._name_ = <span class="string">"maxsoft"</span>;</span><br><span class="line">obj._age = <span class="string">"24"</span>;</span><br><span class="line">obj.private_sex = <span class="string">"男"</span>;</span><br><span class="line">obj.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._name_;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">&#125;</span><br><span class="line">obj.getSex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.private_sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"姓名："</span>+obj.getName());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"年龄："</span>+obj.getAge());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"性别："</span>+obj.getSex());</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src="/uploads/object_002.png">在上述示例我们用到了 this 关键字，该关键词主要表示当前执行的方法所属的对象；那么在我们的示例中的 this 就是指 obj 对象。<br><font color=red><b>注意</b></font>： this 关键字在 ECMAScript 语言中是相对比较重要的知识点。</p>
<h2 id="创建及修改对象"><a href="#创建及修改对象" class="headerlink" title="创建及修改对象"></a>创建及修改对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。在 ECMAScript 语言中，不仅可以创建对象，还可以修改已有对象的行为，这主要得益于对象的 prototype 属性。通过 prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toHex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"0x"</span> + <span class="keyword">this</span>.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.toOct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"0"</span> + <span class="keyword">this</span>.toString(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num.toHex());</span><br><span class="line"><span class="built_in">console</span>.log(num.toOct());</span><br><span class="line"><span class="built_in">Number</span>.prototype.toLocalString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"I am override method;"</span> + <span class="keyword">this</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());</span><br><span class="line"><span class="built_in">console</span>.log(num.toLocalString());</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/modify_obj.png' />上述示例中我们通过对象的 prototype 属性进行对象的一系列的属性修改新增等操作。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此，JavaScript 语言的核心基础知识也算是学习了一遍，补缺了在大学时期没有进行学习的遗漏。同时，也加深了一些基础知识的认知。但是相对于目前工作中使用的 JavaScript 语言的高级用法，这确实只是一点基础！后续的工作中会继续总结使用到的高级用法以及其他的知识点（浏览器对象模型( BOM )、文档对象模型( DOM )）。</p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/21/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%869/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/21/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%869/" class="post-title-link" itemprop="url">JavaScript基础知识整理<九>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-21 19:41:13" itemprop="dateCreated datePublished" datetime="2015-06-21T19:41:13+08:00">2015-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面几个章节系统的学习了 JavaScript 语言的核心基础。即（ ECMAScript 语法，变量，运算符以及语法结构等基础知识），今天主要来学习总结关于 JavaScript 函数相关的基础知识，也是对前面学习的内容进行系统的运用；</p>
<h2 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数就是一组有意义的运算符按照一定的逻辑进行组合而成并且是可以随时随地运行的语句。函数也是 ECMAScript 语言的核心。</p>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>函数的基本语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, ... argN</span>) </span>&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red><b>注释</b></font>：其中 functionName 为函数的名称，arg0,arg1, … argN 为函数的参数，statements 为函数体即函数代码块；</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name,msg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msg + <span class="string">"I am "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = say(<span class="string">"MaxSoft"</span>,<span class="string">"Hello World, "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/function_0.png'>从上面的示例中我们可以看到，即使函数有值，也不用明确地声明它。我们只需要使用 return 运算符将该要当做函数的值返回即可。<br><font color=red><b>注意</b></font>：如果函数无明确的返回值，或调用了没有参数的 return 语句，那么它真正返回的值是 undefined。</p>
<h2 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 函数代码中，使用特殊对象 arguments，我们无需明确指出参数名，就能访问它们。同时，我们也可以通过 arguments 对象检测函数的参数个数，即使用 arguments.length 属性就可以方便的获取函数参数个数。由此，我们也可以创造性的使用 arguments.length 属性来模拟 Java 语言中的重载函数。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">", I am "</span> + <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Welcome "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">"MaxSoft"</span>);</span><br><span class="line">say(<span class="string">"MaxSoft"</span>,<span class="string">"Hello world"</span>);</span><br><span class="line">say();</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/function_1.png'><br><font color=red><b>注意</b></font>：与其他程序设计语言不同，ECMAScript 不会验证传递给函数的参数个数是否等于函数定义的参数个数。我们定义的函数都可以接受任意个数的参数。任何遗漏的参数都会以 undefined 传递给函数，多余的参数函数将忽略。</p>
<h2 id="Function-对象"><a href="#Function-对象" class="headerlink" title="Function 对象"></a>Function 对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 语言中的函数实际上是功能完整的对象。Function 类可以表示我们定义的任何函数。<br>语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> function_name = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argN, function_body</span>)</span></span><br></pre></td></tr></table></figure>
<p>其中 function_name 为函数的名称，arg1, arg2, …, argN都是函数的参数，function_body为函数体即要执行的代码（全部都是字符串）。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>,<span class="string">'msg'</span>,<span class="string">"console.log(name + ' ' + msg)"</span>);</span><br><span class="line">say(<span class="string">'MaxSoft'</span>,<span class="string">'Hi '</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/function_2.png'></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包指函数可以使用函数之外定义的变量。例如在 ECMAScript 中使用全局变量是一个简单的闭包实例，示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> age = <span class="number">24</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(name + <span class="string">":"</span>  + age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			<span class="keyword">return</span><span class="string">"Hello "</span> + name;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Hello world "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中第二个函数 person() 包括函数 say() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 flag 以及全局变量 name 的值。 person() 的最后一步调用了 say()并作为其返回值。<br>这里要掌握的重要概念是，say() 函数根本不接受参数，它使用的值是从执行环境中获取的。<br>由此可以看到，闭包是 ECMAScript 中相对比较高级的部分，可用于执行复杂的计算，当然使用不当也会出现不必要的麻烦。例如，内存溢出，性能问题等。</p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/19/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%868/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/19/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%868/" class="post-title-link" itemprop="url">JavaScript基础知识整理<八>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-19 20:44:10" itemprop="dateCreated datePublished" datetime="2015-06-19T20:44:10+08:00">2015-06-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要来学习总结一下关于 ECMAScript  语言中的相关语句，主要包括if语句，迭代语句( while, do while, for, for-in)， 标签语句( label, state )，中断语句(break, continue)，with语句，switch语句；</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if 语句在 ECMAScript 中和在其他编程语言中一样，也是相对比较常用的语句之一，其语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br><span class="line">或</span><br><span class="line"><span class="keyword">if</span> (condition1) statement1 <span class="keyword">else</span> <span class="keyword">if</span> (condition2) statement2 <span class="keyword">else</span> statement3</span><br></pre></td></tr></table></figure>
<p>其中 condition 可以是任何表达式，计算的结果甚至不必是真正的 boolean 值，ECMAScript 会把它转换成 boolean 值。如果条件计算结果为 true，则执行 statement1；如果条件计算结果为 false，则执行 statement2。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say_hello</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Hello MaxSoft ...... "</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="string">"MaxSoft"</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Hello ...... "</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">" exception ...... "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代语句又叫循环语句，声明一组要反复执行的命令，直到满足某些条件为止。在 ECMAScript 中提供了四种迭代语句 ( while, do while, for, for-in ) 。</p>
<h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title=" do-while 语句 "></a><font color=red> do-while 语句 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do-while 语句是后测试循环，即退出条件在执行循环内部的代码之后计算。这意味着在计算表达式之前，至少会执行循环主体一次。语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;statement&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"开始报数......"</span>);</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i++);</span><br><span class="line">	&#125;<span class="keyword">while</span>(i &lt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title=" while 语句 "></a><font color=red> while 语句 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while 语句是前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。因此，循环主体可能根本不被执行。语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) statement</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"开始报数......"</span>);</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title=" for 语句 "></a><font color=red> for 语句 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) statement</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"开始报数......"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title=" for-in 语句 "></a><font color=red> for-in 语句 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for-in 语句是严格的迭代语句，用于枚举对象的属性。其中 Object 对象的 PropertyIsEnumerable() 是 ECMAScript 中专门用于说明属性是否可以用 for-in 语句访问的方法。语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	obj.name=<span class="string">"MaxSoft"</span>;</span><br><span class="line">	obj.sex=<span class="number">1</span>;</span><br><span class="line">	obj.height=<span class="number">168</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> o <span class="keyword">in</span> obj)&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj.propertyIsEnumerable(<span class="string">'height'</span>) &amp;&amp; o==<span class="string">'height'</span>)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"身高："</span> + obj[o]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj.propertyIsEnumerable(<span class="string">'weight'</span>))&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"体重："</span> + obj[o]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(obj[o]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<img src='/uploads/for_in.png'></p>
<h2 id="中断、标签语句"><a href="#中断、标签语句" class="headerlink" title=" 中断、标签语句 "></a><font color=red> 中断、标签语句 </font></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break 语句可以立即退出循环，阻止再次反复执行任何代码。 continue 语句只是退出当前循环，根据控制表达式还允许继续进行下一次循环。break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"开始报数......"</span>);</span><br><span class="line">	flag:</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span> flag;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">console</span>.log(num++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteration_1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"开始报数......"</span>);</span><br><span class="line">	flag:</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span> flag;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">console</span>.log(num++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red><b>注意</b></font>：可以看出，与 break 和 continue 联合使用的有标签语句非常强大，不过过度使用它们会给调试代码带来麻烦。要确保使用的标签具有说明性，同时不要嵌套太多层循环。</p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title=" with 语句 "></a><font color=red> with 语句 </font></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with 语句用于设置代码在特定对象中的作用域。<br>语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.name=<span class="string">"MaxSoft"</span>;</span><br><span class="line">obj.age=<span class="number">24</span>;</span><br><span class="line">obj.sex=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">with</span>(obj)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">	<span class="built_in">console</span>.log(age);</span><br><span class="line">	<span class="built_in">console</span>.log(sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/with_1.png'>通过上述代码发现，我们使用了with语句关联了 obj 对象，这就意味着在with代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象的属性。<br><font color=red><b>注意</b></font>：由于 with 语句语义相对不太明确，性能较低，并且调试也相对比较困难，所以在浏览器的严格模式下是不可以使用该语句。</p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title=" switch 语句 "></a><font color=red> switch 语句 </font></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 和 Java 中的 switch 语句有两点不同。在 ECMAScript 中，switch 语句可以用于字符串，而且能用不是常量的值来运算。<br>语法结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: statement;</span><br></pre></td></tr></table></figure>
<p><font color=red><b>说明</b></font>：关键字 break 会使代码跳出 switch 语句。如果没有关键字 break，代码执行就会继续进入下一个 case。关键字 default 说明了表达式的结果不等于任何一种情况时的操作。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showInfos</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> BLUE = <span class="string">"blue"</span>, RED = <span class="string">"red"</span>, GREEN  = <span class="string">"green"</span>;</span><br><span class="line">	<span class="keyword">switch</span> (color) &#123;</span><br><span class="line">	  <span class="keyword">case</span> BLUE: <span class="built_in">console</span>.log(BLUE);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> RED: <span class="built_in">console</span>.log(RED);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> GREEN: <span class="built_in">console</span>.log(GREEN);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">"Other"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showInfos_1</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (index) &#123;</span><br><span class="line">	  <span class="keyword">case</span> <span class="number">20</span>: <span class="built_in">console</span>.log(<span class="string">"20"</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> <span class="number">30</span>: <span class="built_in">console</span>.log(<span class="string">"30"</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> <span class="number">40</span>: <span class="built_in">console</span>.log(<span class="string">"40"</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">"other"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/17/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/17/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%8B/" class="post-title-link" itemprop="url">JavaScript基础知识整理<七>-下-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-17 20:14:20" itemprop="dateCreated datePublished" datetime="2015-06-17T20:14:20+08:00">2015-06-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天依然接续上一节的内容进行学习总结，主要有关系运算符，等性运算符，条件运算符，赋值运算符和逗号运算符；</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系运算符执行的是比较运算。主要包括：小于( &lt; )、大于( &gt; )、小于等于( &lt;= )和大于等于( &gt;= )每个关系运算符都返回一个布尔值。执行行为如下：<br>&nbsp;&nbsp;● 如果俩个比较值都是 Number 类型的值，则按照 Number 的值进行比较；<br>&nbsp;&nbsp;● 如果俩个比较值都是字符串类型的值，则按照字符串的首字母的ASCII码值进行比较；<br>&nbsp;&nbsp;● 任何包含 NaN 的关系运算符都要返回 false；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">5</span> &gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"AVC"</span> &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"AVC"</span> &lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ABC"</span> &gt; <span class="string">"BCD"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"abc"</span> &gt; <span class="string">"BCD"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"24"</span> &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src="/uploads/logic_1.png" /><font color=red><b>注意</b></font>：比较一个数字和一个字符串，ECMAScript 都会把字符串转换成数字，然后按照数字顺序比较它们；</p>
<h2 id="等性运算符"><a href="#等性运算符" class="headerlink" title="等性运算符"></a>等性运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断两个变量是否相等是程序设计中非常重要的运算。在处理原始值时，这种运算相当简单，但涉及对象，任务就稍有点复杂。ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。</p>
<h3 id="等号和非等号"><a href="#等号和非等号" class="headerlink" title=" 等号和非等号"></a><font color=red> 等号和非等号</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。为确定两个运算数是否相等，这两个运算符都会进行类型转换。<br>执行规则如下：<br>&nbsp;&nbsp;● 值 null 和 undefined 相等。<br>&nbsp;&nbsp;● 在检查相等性时，不能把 null 和 undefined 转换成其他值。<br>&nbsp;&nbsp;● 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。<br>&nbsp;&nbsp;● 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。<br>特殊行为结果如下：<img src='/uploads/equal_1.png'/><font color=red><b>注意</b></font>：即使两个数都是 NaN，等号仍然返回 false，因为根据规则，NaN 不等于 NaN。</p>
<h3 id="全等号和非全等号"><a href="#全等号和非全等号" class="headerlink" title=" 全等号和非全等号"></a><font color=red> 全等号和非全等号</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。<br>&nbsp;&nbsp;● 全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。<br>&nbsp;&nbsp;● 非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="string">"24"</span>;</span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age == age_1);</span><br><span class="line"><span class="built_in">console</span>.log(age === age_1);</span><br><span class="line"><span class="built_in">console</span>.log(age !== age_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src="/uploads/equal_all.png" />通过上述示例我们可以清晰的理解 等号 与 全等号 的区别。</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;条件运算符通常也被称为三目运算符是 ECMAScript 中功能最多的运算符，它的形式与 Java 中的相同。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> min = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = max &gt; min ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">var</span> result_1 = max &gt; min ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src="/uploads/condition_1.png" /></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;赋值运算分为简单赋值运算和复合赋值运算；<br>&nbsp;&nbsp;● 简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。<br>&nbsp;&nbsp;● 复合赋值运算是由加，减，乘，除运算符或位移运算符加等号（=）实现的。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello, "</span>;</span><br><span class="line">hello += <span class="string">"MaxSoft "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello="</span> + hello);</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line">age += <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"age="</span> + age);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/equal_rich.png'/></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用逗号运算符可以在一条语句中执行多个运算，其常用变量声明中。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">24</span>, name=<span class="string">"MaxSoft"</span>, sex=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>




<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%AD/" class="post-title-link" itemprop="url">JavaScript基础知识整理<七>-中-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-14 14:33:21" itemprop="dateCreated datePublished" datetime="2015-06-14T14:33:21+08:00">2015-06-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一觉睡到大中午，吃个午饭就到这个点了，时间过得好快。继续昨天晚上的作业^M^…….学习和整理总结 ECMAScript 中相关运算符的知识点。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 位运算符是在数字底层（即表示数字的 32 个数位）进行操作；主要包括 <font color=red>非(not)</font>，<font color=red>与(and)</font>，<font color=red>或(or)</font>，<font color=red>异或(xor)</font>，以及<font color=red>左移(&lt;&lt;)，右移(&gt;&gt; , &gt;&gt;&gt;)</font>运算符；其中右移运算符区分<font color=red>有符号右移(&gt;&gt;)</font>和<font color=red>无符号右移(&gt;&gt;&gt;)</font>运算符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 中整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。但是，其所有整数字面量都默认存储为有符号整数；只有使用位运算符才能创建无符号整数。<br>● 有符号整数使用 31 位表示整数值，用第 32 位表示符号，0 表示正数，1 表示负数。范围 -2<sup>31</sup> ~ 2<sup>31</sup>-1</p>
<p>可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。<br/><font color=red><b>正数</b></font>&nbsp;是以真二进制形式存储的，前 31 位中的每一位都表示 2 的幂，从第 1 位（位 0）开始，表示 20，第 2 位（位 1）表示 21。没用到的位用 0 填充，即忽略不计。<br>例如，下图展示的是数 18 的表示法：<img src='/uploads/bit_18.gif'/>&nbsp;示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age.toString(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/bit_18_1.png'/>通过上述结果我可以清楚的看到18的有效二进制码为”10010”；<br/><font color=red><b>负数</b></font>&nbsp;也存储为二进制代码，不过采用的形式是二进制补码。计算数字二进制补码的步骤有三步：<br/>1. 确定该数字的非负版本的二进制表示<br/> 2.求得二进制反码，即要把 0 替换为 1，把 1 替换为 0<br/>3.在二进制反码上加 1<br>以-18为例进行二进制转换：<br/>首先看18的二进制<img src='/uploads/18_A.png' />然后对二进制取反码 <img src='/uploads/18_B.png' />最后进行反码加1即为-18的二进制码<img src='/uploads/18_C.png' /><font color=red><b>无符号整数</b></font>把最后一位作为另一个数位处理。在这种模式中，第 32 位不表示数字的符号，而是值 2<sup>31</sup>。所以，无符号整数的数值范围为 0 到 2<sup>32</sup>-1。</p>
<h3 id="非-not-运算符"><a href="#非-not-运算符" class="headerlink" title=" 非( not )运算符 "></a><font color=red> 非( not )运算符 </font></h3><p>非运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一；<br/>其运算步骤分为三步：<br/>1 把运算数转换成 32 位数字；<br/>2 把二进制数转换成它的二进制反码；<br/>3 把二进制数转换成浮点数；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(~age);</span><br><span class="line"><span class="keyword">var</span> height = <span class="number">168</span>;</span><br><span class="line"><span class="built_in">console</span>.log(~height);</span><br><span class="line"><span class="keyword">var</span> weight = <span class="number">-56</span>;</span><br><span class="line"><span class="built_in">console</span>.log(~weight);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/bit_not.png'/>通过上述示例我们可以得出<font color=red>非运算 NOT </font>实质上是对数字求负，然后减 1。</p>
<h3 id="与-and-运算符"><a href="#与-and-运算符" class="headerlink" title=" 与( and )运算符 "></a><font color=red> 与( and )运算符 </font></h3><p>与运算 AND 由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：<img src='/uploads/and_a.png'/>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;	<span class="comment">//0000000000000000000000000011000</span></span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">13</span>;	<span class="comment">//0000000000000000000000000001101</span></span><br><span class="line"><span class="built_in">console</span>.log(age &amp; age_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/and_exp.png'/></p>
<h3 id="或-or-运算符"><a href="#或-or-运算符" class="headerlink" title=" 或( or )运算符 "></a><font color=red> 或( or )运算符 </font></h3><p>位运算 OR 由符号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，OR 运算符采用下列规则：<img src='/uploads/or_1.png'/>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;	<span class="comment">//0000000000000000000000000011000</span></span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">13</span>;	<span class="comment">//0000000000000000000000000001101</span></span><br><span class="line"><span class="built_in">console</span>.log(age | age_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/or_2.png'/></p>
<h3 id="异或-xor-运算符"><a href="#异或-xor-运算符" class="headerlink" title=" 异或( xor )运算符 "></a><font color=red> 异或( xor )运算符 </font></h3><p>位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。真值表如下：<img src='/uploads/xor_1.png'/>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;	<span class="comment">//0000000000000000000000000011000</span></span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">13</span>;	<span class="comment">//0000000000000000000000000001101</span></span><br><span class="line"><span class="built_in">console</span>.log(age ^ age_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/xor_2.png'/></p>
<h3 id="左移-lt-lt-运算符"><a href="#左移-lt-lt-运算符" class="headerlink" title=" 左移( &lt;&lt; )运算符 "></a><font color=red> 左移( &lt;&lt; )运算符 </font></h3><p>左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="number">1</span>; <span class="comment">// 二进制 00000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>; <span class="comment">// 二进制 00000000000000000000000000011000</span></span><br><span class="line"><span class="built_in">console</span>.log(sex &lt;&lt; <span class="number">10</span>); </span><br><span class="line"><span class="built_in">console</span>.log(age &lt;&lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/left_1.png'/><font color=red><b>注意</b></font>：上述示例在左移数位时，数字右边多出 10 个空位。左移运算用 0 填充这些空位，使结果成为完整的 32 位数字。左移运算保留数字的符号位。例如，如果把 -2 左移 10 位，得到的是 -1024，而不是 1024。</p>
<h3 id="有符号右移-gt-gt-运算符"><a href="#有符号右移-gt-gt-运算符" class="headerlink" title=" 有符号右移( &gt;&gt; )运算符 "></a><font color=red> 有符号右移( &gt;&gt; )运算符 </font></h3><p>有符号右移运算符由两个大于号表示（&gt;&gt;）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。有符号右移运算符恰好与左移运算相反。同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="number">1</span>; <span class="comment">// 二进制 00000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>; <span class="comment">// 二进制 00000000000000000000000000011000</span></span><br><span class="line"><span class="built_in">console</span>.log(sex &gt;&gt; <span class="number">10</span>); </span><br><span class="line"><span class="built_in">console</span>.log(age &gt;&gt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/right_1.png'/></p>
<h3 id="无符号右移-gt-gt-gt-运算符"><a href="#无符号右移-gt-gt-gt-运算符" class="headerlink" title=" 无符号右移( &gt;&gt;&gt; )运算符 "></a><font color=red> 无符号右移( &gt;&gt;&gt; )运算符 </font></h3><p>无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。无符号右移运算用 0 填充所有空位。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="number">1024</span>; <span class="comment">// 二进制 00000000000000000000010000000000</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">2048</span>; <span class="comment">// 二进制 00000000000000000000100000000000</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="number">-1024</span>; <span class="comment">// 二进制 00000000000000000000001000000000</span></span><br><span class="line"><span class="built_in">console</span>.log(sex &gt;&gt;&gt; <span class="number">4</span>); </span><br><span class="line"><span class="built_in">console</span>.log(age &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(temp &gt;&gt;&gt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/right_2.png'/><br/><font color=red><b>注意</b></font>：由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 中的逻辑运算符包括：NOT、AND 和 OR；</p>
<h3 id="逻辑-NOT-运算符"><a href="#逻辑-NOT-运算符" class="headerlink" title=" 逻辑 NOT 运算符 "></a><font color=red> 逻辑 NOT 运算符 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 中，逻辑 NOT 运算符与 C 和 Java 中的逻辑 NOT 运算符相同，都由感叹号（!）表示。与逻辑 OR 和逻辑 AND 运算符不同的是，<font color=red>逻辑 NOT 运算符返回的一定是 Boolean 值</font>。<br>逻辑 NOT 运算符的行为如下：<br>&nbsp;&nbsp;● 如果运算数是对象，返回 false；<br>&nbsp;&nbsp;● 如果运算数是数字 0，返回 true；<br>&nbsp;&nbsp;● 如果运算数是 0 以外的任何数字，返回 false；<br>&nbsp;&nbsp;● 如果运算数是 null，返回 true；<br>&nbsp;&nbsp;● 如果运算数是 NaN，返回 true；<br>&nbsp;&nbsp;● 如果运算数是 undefined，发生错误；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp_1 = <span class="string">"temp_1"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"(!temp_1)="</span>+ !temp_1);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"(!temp_1)="</span>+ !!temp_1);</span><br><span class="line"><span class="keyword">var</span> num_1 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"(!num_1)="</span>+ !num_1);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"(!num_1)="</span>+ !!num_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/boolean_not.png'/><br/><font color=red><b>注意</b></font>：判断 ECMAScript 变量的 Boolean 值时，也可以使用逻辑 NOT 运算符。这样做需要在一行代码中使用两个 NOT 运算符。无论运算数是什么类型，第一个 NOT 运算符返回 Boolean 值。第二个 NOT 将对该 Boolean 值求负，从而给出变量真正的 Boolean 值。</p>
<h3 id="逻辑-AND-运算符"><a href="#逻辑-AND-运算符" class="headerlink" title=" 逻辑 AND 运算符 "></a><font color=red> 逻辑 AND 运算符 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 中，逻辑 AND 运算符用双和号（&amp;&amp;）表示，其运算行为如下：<img src='/uploads/boolean_and.png' />逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值。如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值：<br>&nbsp;&nbsp;● 如果一个运算数是对象，另一个是 Boolean 值，返回该对象。<br>&nbsp;&nbsp;● 如果两个运算数都是对象，返回第二个对象。<br>&nbsp;&nbsp;● 如果某个运算数是 null，返回 null。<br>&nbsp;&nbsp;● 如果某个运算数是 NaN，返回 NaN。<br>&nbsp;&nbsp;● 如果某个运算数是 undefined，发生错误。<br>与 Java 中的逻辑 AND 运算相似，ECMAScript 中的逻辑 AND 运算也是简便运算，即如果第一个运算数决定了结果，就不再计算第二个运算数。对于逻辑 AND 运算来说，如果第一个运算数是 false，那么无论第二个运算数的值是什么，结果都不可能等于 true。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boo_1 = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(boo_1 || temp); <span class="comment">//这里temp为undefined</span></span><br><span class="line"><span class="keyword">var</span> boo_2 = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(boo_2 &amp;&amp; temp); <span class="comment">//这里temp为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(boo_1 &amp;&amp; temp); <span class="comment">//这里temp为undefined</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/boolean_and_1.png' />通过上述示例可以发现，<font color=red>「AND 运算符和 Java 中一样，也存在短路运算的特性」</font>。</p>
<h3 id="逻辑-OR-运算符"><a href="#逻辑-OR-运算符" class="headerlink" title=" 逻辑 OR 运算符 "></a><font color=red> 逻辑 OR 运算符 </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 中的逻辑 OR 运算符与 Java 中的相同，都由双竖线（||）表示。逻辑 OR 运算符的行为如下：<img src='/uploads/boolean_or_1.png' />与逻辑 AND 运算符相似，如果某个运算数不是 Boolean 值，逻辑 OR 运算并不一定返回 Boolean 值：<br>&nbsp;&nbsp;● 如果一个运算数是对象，并且该对象左边的运算数值均为 false，则返回该对象。<br>&nbsp;&nbsp;● 如果两个运算数都是对象，返回第一个对象。<br>&nbsp;&nbsp;● 如果最后一个运算数是 null，并且其他运算数值均为 false，则返回 null。<br>&nbsp;&nbsp;● 如果最后一个运算数是 NaN，并且其他运算数值均为 false，则返回 NaN。<br>&nbsp;&nbsp;● 如果某个运算数是 undefined，发生错误。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boolean_1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> boolean_2 = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(boolean_1 || temp);</span><br><span class="line"><span class="built_in">console</span>.log(boolean_1 || boolean_2);</span><br><span class="line"><span class="built_in">console</span>.log(temp || boolean_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/boolean_or_2.png' />通过上述示例可以发现，<font color=red>「OR 运算符和 Java 中一样，也存在短路运算的特性」</font>。</p>
<p>又一个周末结束了，时间过得真快 …… 到饭点儿了，走起 …… </p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/13/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/13/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867%E4%B8%8A/" class="post-title-link" itemprop="url">JavaScript基础知识整理<七>-上-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-13 19:13:11" itemprop="dateCreated datePublished" datetime="2015-06-13T19:13:11+08:00">2015-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天玩的有点嗨了，回来居然进入不了学习的状态，嚓嚓 …… 言归正传，我们前一节总结了引用类型的相关知识点，本节主要学习和整理总结 ECMAScript 中相关运算符的知识点。</p>
<h2 id="类型运算符"><a href="#类型运算符" class="headerlink" title="类型运算符"></a>类型运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言中提供的关于类型相关的运算符有俩个，分别是 typeof 和 instanceof；在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”；而 instanceof 则是 ECMAScript 语言中用来解决这个问题。</p>
<h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>typeof 运算符有一个参数，即要检查的变量或值；对变量或值调用 typeof 运算符将返回下列值之一：<br>● undefined - 如果变量是 Undefined 类型的<br>● boolean - 如果变量是 Boolean 类型的<br>● number - 如果变量是 Number 类型的<br>● string - 如果变量是 String 类型的<br>● object - 如果变量是一种引用类型或 Null 类型的</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/typeof_1.png'></p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg <span class="keyword">instanceof</span> <span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> msg);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/instanceof.png'></p>
<h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一元运算符只有一个参数，即要操作的对象或值。例如 delete , void , ++ , + , - - , - 等，它们是 ECMAScript 中最简单的运算符。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title=" delete "></a><font color=red> delete </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该运算符是删除当前对象的自定义属性或方法的引用，但是不能删除系统默认的属性和方法。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">employee.name = <span class="string">"MaxSoft"</span>;</span><br><span class="line">employee.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(employee.name);</span><br><span class="line"><span class="keyword">delete</span> employee.name;</span><br><span class="line"><span class="built_in">console</span>.log(employee.name);</span><br><span class="line"><span class="keyword">delete</span> employee.toString</span><br><span class="line"><span class="built_in">console</span>.log(employee.toString());</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/delete.png'/>从上述的运行结果我们看到，name 属性被删除后，再访问其结果就变成了 undefined ；而 toString 方法被删除后，再访问其依然有效。</p>
<h3 id="void"><a href="#void" class="headerlink" title=" void "></a><font color=red> void </font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该运算符对任何值返回 undefined，通常用于避免输出不应该输出的值。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win_res = <span class="built_in">window</span>.open(<span class="string">'about:blank'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(win_res);</span><br><span class="line"><span class="keyword">var</span> win_res_1 = <span class="keyword">void</span>(<span class="built_in">window</span>.open(<span class="string">'about:blank'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(win_res_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/void.png'/>通过以上代码发现，没有使用 void 运算符则返回了有效的结果，而使用 void 运算符则返回了 undefined；</p>
<h3 id="增量-减量"><a href="#增量-减量" class="headerlink" title=" 增量/减量(++ / - -)"></a><font color=red> 增量/减量(++ / - -)</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一元（前，后）增量和一元（前，后）减量是直接从 C（和 Java）借用的两个运算符。这两个运算符使用的情况分为四种。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++age);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age_1++);</span><br><span class="line"><span class="built_in">console</span>.log(age_1);</span><br><span class="line"><span class="keyword">var</span> age_2 = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(--age_2);</span><br><span class="line"><span class="built_in">console</span>.log(age_2);</span><br><span class="line"><span class="built_in">console</span>.log(age_2--);</span><br><span class="line"><span class="built_in">console</span>.log(age_2);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/dubble_plus_sub.png'/>通过上诉运行结果我们可以得出如下结论：<br>● <font color=red><b>++</b></font>：如果在变量前面则先执行运算再使用变量，如果在变量后面则先使用变量再执行运算；<br>● <font color=red><b>- -</b></font>：如果在变量前面则先执行运算再使用变量，如果在变量后面则先执行运算再使用变量；</p>
<h3 id="加减"><a href="#加减" class="headerlink" title=" 加减(+ / -)"></a><font color=red> 加减(+ / -)</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一元加法和一元减法运算符和我们数学中的加法减法用法相同。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age =<span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(-age);</span><br><span class="line"><span class="built_in">console</span>.log(+age);</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft："</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name + age);</span><br><span class="line"><span class="built_in">console</span>.log(name - age);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/plus_sub.png'/>通过上述运行结果我们发现，一元加法除了与数学中的加法相同的用法外， 在编程语言中还有字符串的拼接功能，而减法则没有；</p>
<h2 id="加-减-乘-除-取模运算符"><a href="#加-减-乘-除-取模运算符" class="headerlink" title="加|减|乘|除|取模运算符"></a>加|减|乘|除|取模运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 加（+），减（-），乘（*），除（/），取模（%）运算符和我们高中数学中的用法完全相同。</p>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法(+)"></a><font color=red>加法(+)</font></h3><p>该运算符在处理特殊值时，ECMAScript 中的加法也有一些特殊行为：<br>● 某个运算数是 NaN，那么结果为 NaN<br>● -Infinity 加 -Infinity，结果为 -Infinity<br>● Infinity 加 -Infinity，结果为 NaN<br>● +0 加 +0，结果为 +0<br>● -0 加 +0，结果为 +0<br>● 6. -0 加 -0，结果为 -0<br>如果某个运算数是字符串，那么采用下列规则：<br>● 如果两个运算数都是字符串，把第二个字符串连接到第一个上。<br>● 如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span> + <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"><span class="keyword">var</span> code = <span class="string">"55"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number + code);</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"MaxSoft ："</span> + number;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(result + code);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/add.png'/>通过上述示例我们可以非常清晰的理解加法（+）运算符俩种用法的差别；</p>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法(-)"></a><font color=red>减法(-)</font></h3><p>该运算符与加法运算符一样，在处理特殊值时，也有一些特殊行为：<br>● 某个运算数是 NaN，那么结果为 NaN<br>● Infinity 减 Infinity，结果为 NaN<br>● -Infinity 减 -Infinity，结果为 NaN<br>● Infinity 减 -Infinity，结果为 Infinity<br>● -Infinity 减 Infinity，结果为 -Infinity<br>● +0 减 +0，结果为 +0<br>● -0 减 -0，结果为 -0<br>● +0 减 -0，结果为 +0<br>● 某个运算符不是数字，那么结果为 NaN<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> code = <span class="string">"code"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number - num);</span><br><span class="line"><span class="built_in">console</span>.log(num - number);</span><br><span class="line"><span class="built_in">console</span>.log(number - code);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> - num);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> - num);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> - num);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> - num);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/sub.png'/>通过上述示例我们可以看到如果运算数都是数字，那么执行常规的减法运算，并返回结果；否则返回NaN；<br/><font color=red><b>注意</b>：这里的 null , false , true 执行了类型隐式转换后进行运算</font>&nbsp;</p>
<h3 id="乘法-lowast"><a href="#乘法-lowast" class="headerlink" title="乘法(&lowast;)"></a><font color=red>乘法(&lowast;)</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乘法运算符由星号（*）表示，用于两个操作数进行相乘。ECMAScript 中的乘法语法与 C 语言中的相同；但是，在处理特殊值时，ECMAScript 中的乘法也存在一些特殊的行为：<br>● 如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。<br>● 如果某个运算数是 NaN，结果为 NaN。<br>● Infinity 乘以 0，结果为 NaN。<br>● Infinity 乘以 0 以外的任何数字，结果为 Infinity 或 -Infinity。<br>● Infinity 乘以 Infinity，结果为 Infinity。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">4</span> * <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> pi = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(age * pi);</span><br><span class="line"><span class="built_in">console</span>.log(pi * pi);</span><br><span class="line"><span class="built_in">console</span>.log(age * name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> * age);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/mult.png'/>通过上述示例我们可以更加直观的看到如果运算数是数字，那么执行常规的乘法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。</p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法(/)"></a><font color=red>除法(/)</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除法运算符由斜杠（/）表示，用第二个运算数除第一个运算数。该运算符与乘法运算符相似，在处理特殊值时，该运算符也有一些特殊行为：<br>● 如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。<br>● 如果某个运算数是 NaN，结果为 NaN。<br>● Infinity 被 Infinity 除，结果为 NaN。<br>● Infinity 被任何数字除，结果为 Infinity。<br>● 0 除一个任何非无穷大的数字，结果为 NaN。<br>● Infinity 被 0 以外的任何数字除，结果为 Infinity 或 -Infinity。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">48</span> / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pi = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(age / pi);</span><br><span class="line"><span class="built_in">console</span>.log(pi / pi);</span><br><span class="line"><span class="built_in">console</span>.log(age / name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> / age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> / age);</span><br><span class="line"><span class="built_in">console</span>.log(age / <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/divsion.png'/>通过上述示例我们可以更加直观的看到，如果运算数是数字，那么执行常规的除法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。</p>
<h3 id="取模"><a href="#取模" class="headerlink" title="取模(%)"></a><font color=red>取模(%)</font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除法（余数）运算符由百分号（%）表示。该运算符与上述其他运算符相似，对于特殊值，该运算符也有其特殊的行为：<br>● 如果被除数是 Infinity，或除数是 0，结果为 NaN<br>● Infinity 被 Infinity 除，结果为 NaN<br>● 如果除数是无穷大的数，结果为被除数<br>● 如果被除数为 0，结果为 0<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age%temp);</span><br><span class="line"><span class="built_in">console</span>.log(temp%age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>%age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/age);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/modle.png'/>通过上述示例我们可以更加直观的看到，如果运算数是数字，那么执行常规的算术除法运算，返回除法运算得到的余数。</p>
<p><font color=red><b>注意</b>：上述运算符中，只要有一个操作数为NaN，则结果就会返回NaN；</font></p>
<p>呃呃…… 又到凌晨1点了。洗洗睡，明天继续……<br>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/12/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%866/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/12/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%866/" class="post-title-link" itemprop="url">JavaScript基础知识整理<六>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-12 20:23:31" itemprop="dateCreated datePublished" datetime="2015-06-12T20:23:31+08:00">2015-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要学习并总结 ECMAScript 语言中引用类型相关的知识点。引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMAScript 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。<br>对象是由 new 运算符加上要实例化的对象的名字创建的，这种语法与 Java 语言类似，不过当有不止一个参数时，ECMAScript 要求使用括号。如果没有参数，括号也可以省略「尽管括号不是必需的，但是为了避免混乱，最好使用括号」。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj_0 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object 对象自身用处不大，不过在了解其他类之前，还是应该了解它。因为 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。<br>以下为 Object 对象的属性：<br/><font color=red>constructor</font>：对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。<br/><font color=red>prototype</font>：对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。<br>以下为 Object 对象的方法：<br/><font color=red>hasOwnProperty(property)</font><br>判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)）<br><font color=red>isPrototypeOf(object)</font><br>判断该对象是否为另一个对象的原型。<br><font color=red>propertyIsEnumerable(property)</font><br>判断给定的属性是否可以用 for…in 语句进行枚举。<br><font color=red>toString()</font><br>返回对象的原始字符串表示。<br><font color=red>valueOf()</font><br>返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name=<span class="string">"MaxSoft"</span>;</span><br><span class="line">obj.age=<span class="number">24</span>;</span><br><span class="line">obj.height=<span class="number">168</span>;</span><br><span class="line">obj.like=[<span class="string">'football'</span>,<span class="string">'basketball'</span>,<span class="string">'computer'</span>];</span><br><span class="line">obj.isMan=<span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object_1</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object_2</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Object_2.prototype = <span class="built_in">Object</span>.create(Object_1.prototype);</span><br><span class="line">obj_2 = <span class="keyword">new</span> Object_2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'name'</span>) + <span class="string">"&lt;---&gt;"</span> + obj.hasOwnProperty(<span class="string">'name_0'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">'age'</span>) + <span class="string">"&lt;---&gt;"</span> + obj.propertyIsEnumerable(<span class="string">'age_0'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Object_1.prototype.isPrototypeOf(obj_2) + <span class="string">"&lt;---&gt;"</span> + <span class="built_in">Object</span>.prototype.isPrototypeOf(obj_2));</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString() + <span class="string">"&lt;---&gt;"</span> + obj.valueOf());</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/prototypeof.png'></p>
<h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean 对象是 Boolean 原始类型的引用类型。创建 Boolean 对象，只需要传递 Boolean 值作为参数即可。Boolean 对象将覆盖 Object 对象的 ValueOf() 方法，返回原始值，即 true 和 false。ToString() 方法也会被覆盖，返回字符串 “true” 或 “false”。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExists = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isExists.toString());</span><br><span class="line"><span class="built_in">console</span>.log(isExists.valueOf());</span><br><span class="line"><span class="keyword">var</span> result = isExists &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/boolean_1.png' /></p>
<h2 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number 对象是 Number 原始类型的引用类型。要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法即可。Number 类型的特殊值都是 Number 对象的静态属性。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> age_0 = age.valueOf();</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(age.toString());</span><br><span class="line"><span class="built_in">console</span>.log(age_0);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：<img src='/uploads/number_1.png' />以下为 Number 对象几个处理数值的专用方法：<br>1&gt; <font color=red>toFixed()</font>：toFixed() 方法返回的是具有指定位数小数的数字的字符串表示；<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weight = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weight.toFixed(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(weight.toFixed(<span class="number">23</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/tofixed_1.png'>2&gt; <font color=red>toExponential()</font>：它返回的是用科学计数法表示的数字的字符串形式。与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3.141592654</span>);</span><br><span class="line"><span class="keyword">var</span> weight = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">50000000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.toExponential(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(p.toExponential(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(weight.toExponential(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(weight.toExponential(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/toexponential.png' />3&gt; <font color=red>toPrecision()</font>：根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weight = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">56</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weight.toPrecision(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(weight.toPrecision(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(weight.toPrecision(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/toprecision.png'><br><font color=red><b>注意</b></font>：toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。</p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String 对象是 String 原始类型的对象表示法。String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello maxsoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg);</span><br><span class="line"><span class="built_in">console</span>.log(msg.toString() === msg.valueOf());</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：<img src='/uploads/string_1.png'>以下为 String 对象的属性：<br/><font color=red>length </font>：返回字符串中的字符个数，及字符串的长度；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.length);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/length_1.png'></p>
<p>以下为 String 对象部分常用方法：<br/><font color=red>charAt()</font>：返回的是包含指定位置处的字符的字符串；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.charAt(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/charat_1.png'><font color=red>charCodeAt()</font>：返回指定位置的字符的字符代码；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.charCodeAt(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/charcodeat_1.png'><font color=red>concat()</font>：用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="keyword">var</span> say = msg.concat(<span class="string">' ...... '</span>);</span><br><span class="line"><span class="built_in">console</span>.log(say);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/concat.png'><font color=red>indexOf()</font>：从字符串的开头（位置 0）开始检索字符串，并返回其位置，否则返回-1；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.indexOf(<span class="string">'M'</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/indexof.png'><font color=red>lastIndexOf()</font>：从字符串的结尾开始检索子串，并返回其位置，否则返回-1；<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.lastIndexOf(<span class="string">'M'</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/lastindexof.png'><font color=red>localeCompare()</font>：对字符串进行排序；<br/>如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。<br>如果 String 对象等于参数中的字符串，返回 0<br>如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.localeCompare(<span class="string">'america'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(msg.localeCompare(<span class="string">'hello MaxSoft'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(msg.localeCompare(<span class="string">'university'</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/localecompare.png'><font color=red>slice() 和 substring()</font>：这两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。<br>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.slice(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(msg.slice(<span class="number">-5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(msg.substring(<span class="number">2</span>,<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(msg.substring(<span class="number">0</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/slice_substring.png'><font color=red>toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()</font>：这4 种方法用于执行大小写转换。前两种方法用于把字符串转换成全小写的，后两种方法用于把字符串转换成全大写的；<br/>toLowerCase() 和 toUpperCase() 方法是原始的，是以 java.lang.String 中相同方法为原型实现的。<br/>toLocaleLowerCase() 和 toLocaleUpperCase() 方法是基于特定的区域实现的（与 localeCompare() 方法相同）<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello MaxSoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg.toLocaleUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(msg.toUpperCase());	</span><br><span class="line"><span class="built_in">console</span>.log(msg.toLocaleLowerCase());</span><br><span class="line"><span class="built_in">console</span>.log(msg.toLowerCase());</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/low_up.png'></p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/10/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/10/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%865/" class="post-title-link" itemprop="url">JavaScript基础知识整理<五>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-10 20:13:21" itemprop="dateCreated datePublished" datetime="2015-06-10T20:13:21+08:00">2015-06-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一节我们总结了 ECMAScript 语言的数据类型，今天主要总结 ECMAScript 语言的数据类型相关的转换过程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机程序设计语言其重要的特征之一就是具有类型转换的能力。ECMAScript 也不例外，它给我们提供了大量简单的类型转换方法。多数类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。无论哪种情况，在 ECMAScript 语言中，类型转换都是相对简短的一步操作。</p>
<h2 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言中的 Boolean 值、数字和字符串的原始值的都是「伪对象」，这意味着它们实际上具有属性和方法。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> isMan=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1992-01-01'</span>);</span><br><span class="line"><span class="keyword">var</span> like = [<span class="string">'football'</span>,<span class="string">'baskedball'</span>,<span class="string">'cumputer'</span>];</span><br><span class="line"><span class="keyword">var</span> attr = &#123;<span class="attr">id</span>:<span class="string">'0001'</span>,<span class="attr">code</span>:<span class="string">'MaxSoft'</span>,<span class="attr">des</span>:<span class="string">'This is my code'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name.toString());</span><br><span class="line"><span class="built_in">console</span>.log(age.toString());</span><br><span class="line"><span class="built_in">console</span>.log(age.toString(<span class="number">2</span>)); <span class="comment">//指定转换2进制模式</span></span><br><span class="line"><span class="built_in">console</span>.log(age.toString(<span class="number">8</span>)); <span class="comment">//指定转换为8进制模式</span></span><br><span class="line"><span class="built_in">console</span>.log(age.toString(<span class="number">16</span>)); <span class="comment">//指定转换为16进制模式</span></span><br><span class="line"><span class="built_in">console</span>.log(isMan.toString());</span><br><span class="line"><span class="built_in">console</span>.log(birthday.toString());</span><br><span class="line"><span class="built_in">console</span>.log(like.toString());</span><br><span class="line"><span class="built_in">console</span>.log(attr.toString());</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/tostring.png' /><br><font color=red><b>注意：</b>Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。</font></br><font color=red>默认模式</font>：toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）；<br/><font color=red>基模式</font>：可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。</p>
<h2 id="转换为数字"><a href="#转换为数字" class="headerlink" title="转换为数字"></a>转换为数字</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 和 parseFloat()。前者是把值转换成整数，后者是把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的则是 NaN。</p>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。这一过程将持续到发现非有效数字的字符为止，此时 parseInt() 将把该字符之前的字符串转换成数字。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseInt() 方法也有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由 parseInt() 方法的第二个参数指定的。<br>具体代码示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"24MaxSoft"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xA"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"56.5"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"MaxSoft"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"24"</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"11000"</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"30"</span>, <span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"18"</span>, <span class="number">16</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/parseint.png'></p>
<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseFloat() 方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN 或 0，因为在浮点数中，x 不是有效字符。此外，parseFloat() 方法也没有基模式。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"24MaxSoft"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"0xAB"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"56.7"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"56.22.33"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"01067"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"red"</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/parsefloat.png' /></p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ECMAScript 语言中提供了多种类型的强制类型转换方式。分别是 Boolean(value)，Number(value)，String(value) ；使用这些函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。</p>
<h3 id="Boolean-函数"><a href="#Boolean-函数" class="headerlink" title="Boolean() 函数"></a>Boolean() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">""</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">"hello"</span>));	</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">50</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/boolean_.png'/></p>
<h3 id="Number-函数"><a href="#Number-函数" class="headerlink" title="Number() 函数"></a>Number() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"1.2"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"12"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"1.2.3"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：<img src='/uploads/number_.png'/></p>
<h3 id="String-函数"><a href="#String-函数" class="headerlink" title="String() 函数"></a>String() 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。要执行这种强制类型转换，只需要调用作为参数传递进来的值的 toString() 方法。强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="built_in">String</span>(<span class="string">"maxsoft"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="keyword">var</span> name_0 = <span class="built_in">String</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name_0);</span><br><span class="line"><span class="keyword">var</span> sex = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sex);</span><br><span class="line"><span class="keyword">var</span> sex_0 = sex.toString();</span><br><span class="line"><span class="built_in">console</span>.log(sex_0);</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/string_.png' /><br>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/08/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%864/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/08/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%864/" class="post-title-link" itemprop="url">JavaScript基础知识整理<四>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-08 20:43:22" itemprop="dateCreated datePublished" datetime="2015-06-08T20:43:22+08:00">2015-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 今天主要总结 ECMAScript 语言的值类型。 在 ECMAScript 语言中，变量可以存储两种类型的值，即原始类型值和引用类型值。<font color=red>在 ECMAScript 提供了 typeof 运算符来判断一个值是某种类型</font>。如果它是原始类型，还可以判断它表示哪种原始类型。 typeof 方法的参数可以是变量名也可以是具体的值。如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(name));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(age));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">"Hello, MaxSoft!"</span>));</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<img src='/uploads/typeof_fun.png'></p>
<h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始值是指存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。ECMAScript 有 5 种原始类型（primitive type），即 <font color=red>Undefined</font>、<font color=red>Null</font>、<font color=red>Boolean</font>、<font color=red>Number</font> 和 <font color=red>String</font>。值得注意的是在 Java, C++ 语言中， String（字符串）都被当作引用类型，而非原始类型，因为 String（字符串）的长度是可变的。但是，在ECMAScript 语言中打破了这一传统。</p>
<h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Undefined 的类型只有一个值，即 undefined。当声明的变量没有初始化时，该变量的默认值就是 undefined。<br>我们来看如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> temp);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"temp="</span> + temp);</span><br><span class="line"><span class="built_in">console</span>.log(temp == <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下：<img src='/uploads/undefined_0.png'>通过以上代码运行的结果可以看到，声明变量 temp 没有初始化值时，该变量将被赋予值 undefined。<br><font color=red><b>注意：</b>值 undefined 并不同于未定义的值。但是，由于 typeof 的特殊性，该运算符并不真正区分这两种值。</font>示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(temp));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(temp_0)); <span class="comment">// 处理未申明的变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 查看没有返回值的函数的返回值</span></span><br><span class="line"><span class="keyword">if</span>(temp_0)&#123; <span class="comment">// 对于没有申明的变量进行使用时会发生怎么样的结果？</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello MaxSoft.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下图<img src='/uploads/undefined_1.png'>通过以上运行结果可以看到，<font color=red>即使变量 temp_0 从未被声明过，依然可以使用 typeof 来进行运算，函数没有返回值时其返回值也是 undefined 。如果对 temp_0 使用除 typeof 之外的其他运算符的话，则会引起错误。这也是我们在编写 ECMAScript 代码的时候，为什么要在变量不确定的地方使用 typeof 来进行处理的原因；</font></p>
<h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Null类型只有一个值 null。值 undefined 实际上是从值 null 派生来的，因此在 ECMAScript 中这两个值是相等的。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="literal">null</span>; <span class="comment">// 该对象为空值，即没有任何内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(temp);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> temp);</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(temp == <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/undefined_2.png'>通过上面的运行结果我们可以理解，<font color=red>尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示对象为空。如果函数或方法要返回的是对象，那么该对象为空时，则返回 null。</font></p>
<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean 类型是多数编程语言中常见的类型之一，ECMAScript 语言也不例外。Boolean 类型有两个值 true 和 false。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExists = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isExists);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> === <span class="number">0</span>); <span class="comment">// 不进行类型转换，直接比较其值（后面总结）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="number">0</span>); <span class="comment">// 默认转换类型后，进行比较值</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/boolean.png' />通过以上运行结果我们值的注意的是，即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。<br><font color=red><b>注意：</b>=== 表示恒等，首先比较两边的变量数据类型是否相等，其次比较两边的变量的数值是否相等；== 表示相等即仅仅比较两边变量的数值是否相等；（后面详细总结）</font></p>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number 类型在 ECMAScript 语言中是相对比较特殊的类型。该类型既可以表示 32 位的整数，还可以表示 64 位的浮点数。在 ECMAScript 语言中直接输入的任何数字都被看做 Number 类型的值。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">26</span>;</span><br><span class="line"><span class="keyword">var</span> height=<span class="number">168</span>;</span><br></pre></td></tr></table></figure>
<p><font color=red>八进制</font>：首数字必须是 0，其后的数字可以是任何八进制数字（0-7）<br><font color=red>十六进制</font>：首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）<br><font color=red>浮点数</font>：必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）<br><font color=red>科学计数法</font>：科学计数法即把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数<br><font color=red><b>注意：</b>尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。十六进制字母可以是大写的，也可以是小写的。</font><br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="keyword">var</span> age_0 = <span class="number">030</span>;  <span class="comment">// 060 等于十进制的 24</span></span><br><span class="line"><span class="built_in">console</span>.log(age_0);</span><br><span class="line"><span class="keyword">var</span> age_1 = <span class="number">0x18</span>;  <span class="comment">// 0x1e 等于十进制的 24</span></span><br><span class="line"><span class="built_in">console</span>.log(age_1);</span><br><span class="line"><span class="keyword">var</span> age_2 = <span class="number">0xA5</span>;  <span class="comment">// 0xA5 等于十进制的 165</span></span><br><span class="line"><span class="built_in">console</span>.log(age_2);</span><br><span class="line"><span class="keyword">var</span> num_0 = <span class="number">5.0</span>; <span class="comment">// 浮点数</span></span><br><span class="line"><span class="built_in">console</span>.log(num_0);</span><br><span class="line"><span class="keyword">var</span> num_1 = <span class="number">3.1415e7</span> <span class="comment">// 科学计数法</span></span><br><span class="line"><span class="built_in">console</span>.log(num_1);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/number.png' /></p>
<h4 id="特殊的-Number-值"><a href="#特殊的-Number-值" class="headerlink" title="特殊的 Number 值"></a>特殊的 Number 值</h4><p><font color=red>Number.MAX_VALUE</font> 和 <font color=red>Number.MIN_VALUE</font> 定义了 Number 值集合的外边界。<br>当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。<br><font color=red>Number.POSITIVE_INFINITY</font> 和 <font color=red>Number.NEGATIVE_INFINITY</font>  定义了 Number 值的正无穷大和负无穷大。<br>当计算生成的数小于 Number.MIN_VALUE 时，它将被赋予值 Number.NEGATIVE_INFINITY，意味着不再有数字值。<br><font color=red>NaN</font> 表示非数（Not a Number）。NaN 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等。<br>示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="literal">NaN</span> == <span class="literal">NaN</span> ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"red"</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"888"</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：<img src='/uploads/nan.png'/></p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String 类型是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1，如下图：<img src='/uploads/string.gif'/><br>字符串字面量是由双引号（”）或单引号（’）声明的。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> msg=<span class="string">'Hello MaxSoft'</span>;</span><br></pre></td></tr></table></figure>
<p>ECMAScript中转义符列表如下：<img src='/uploads/string_0.png' /></p>
<h2 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用值是指存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 <font color=red>Undefined</font>、<font color=red>Null</font>、<font color=red>Boolean</font>、<font color=red>Number</font> 和 <font color=red>String</font>。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度，影响程序的效率。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。如下图所示：<img src='/uploads/heap_stack.png'></p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/07/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/07/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%863/" class="post-title-link" itemprop="url">JavaScript基础知识整理<三>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-07 14:23:02" itemprop="dateCreated datePublished" datetime="2015-06-07T14:23:02+08:00">2015-06-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一章节总结了 ECMAScript 的语法结构，今天主要总结 ECMAScript 变量以及关键字和保留关键字。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言使用 var 运算符声明变量。变量名需要遵守一些简单的规则。</p>
<h3 id="变量申明"><a href="#变量申明" class="headerlink" title="变量申明"></a>变量申明</h3><p>ECMAScript 中的变量是用 var 运算符（variable 的缩写）加变量名进行定义。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，声明了变量 name , age , sex 并进行了相对应的初始化值操作。由于 ECMAScript 是弱类型语言，所以解释程序会为变量自动创建对应的初始化值数据类型，无需明确的类型声明。<br>我们还可以通过 var 同时定义多个变量名，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>, age = <span class="number">24</span>, sex = <span class="literal">false</span>, msg;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们发现用同一个 var 语句定义的变量不具有相同的类型也是可以的。与 Java 不同，ECMAScript 中的变量并不一定要初始化（例如上面例子中的 msg 就没有初始化值）。</p>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言申明变量名和 Java 语言一样，需要遵守以下两条简单的规则（必须）：<br>1&gt; 首字符必须是字母、下划线（_）或美元符号（$）<br>2&gt; 除首字母外的其他字符可以是下划线、美元符号或任何字母或数字字符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> _name_1 = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> $sex = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p> ECMAScript 的变量名命名规则和 Java , C++ 等语言类似，都有以下著名的命名规则：<br> 1&gt; <font color=red>Camel 标记法（驼峰标记法） ：</font>首字母是小写的，接下来的字母都以大写字符开头。例如：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><br> 2&gt; <font color=red>Pascal 标记法（帕斯卡标记法）：</font>首字母是大写的，接下来的字母都以大写字符开头。例如：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IsExist = <span class="literal">false</span>, Name = <span class="string">"MaxSoft"</span>, BeginDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014-07-01'</span>);</span><br></pre></td></tr></table></figure><br>3&gt; <font color=red>匈牙利类型标记法：</font>在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串等，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bIsExist = <span class="literal">false</span>;  <span class="comment">// b 表示 boolean 类型</span></span><br><span class="line"><span class="keyword">var</span> sName = <span class="string">"MaxSoft"</span>; <span class="comment">// s 表示字符串类型</span></span><br><span class="line"><span class="keyword">var</span> iAge = <span class="number">24</span>; <span class="comment">// i 表示数字整型类型</span></span><br></pre></td></tr></table></figure>
<p>如下为匈牙利类型标记法常用的前缀：<img src='/uploads/var_name_reg.png'> ECMAScript 语言另一个比较神奇的方面就是在使用变量之前可以不申明，直接使用。如下所示：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name  = <span class="string">"MaxSoft"</span>;</span><br><span class="line">hello_msg = <span class="string">"Hello, "</span> + name;</span><br><span class="line"><span class="built_in">console</span>.log(hello_msg);</span><br></pre></td></tr></table></figure><br> 以上示例的运行结果如下所示：<img src='/uploads/hello_msg_res.png'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 的解释器中遇到未声明的标识符时，用该变量名创建一个全局变量，并将其初始化为指定的值。这是 ECMAScript 语言的便利之处，但是这种做法相对比较不可取，最好的习惯是像使用其他程序设计语言一样，在使用变量前，进行必要的申明。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript 语言中的关键字大部分都和 Java, C++ 等程序设计语言类似，都包含以下关键字：<img src='/uploads/key_word.png'> 在 ECMAScript 语言中关键字也是不能被当做变量名来使用。如下：<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">delete</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">break</span>=<span class="string">"MaxSoft"</span>;</span><br></pre></td></tr></table></figure><br> 运行结果如下图：<br> Google Chrome<img src='/uploads/key_word_exce.png'>IE9<img src='/uploads/key_word_exce_ie.png'>从以上俩种异常运行结果可以看到由于每种浏览器的 ECMAScript 语言解释器不同，所以抛出的异常信息可能不太一样，但是最终的意义都是一样的。</p>
<h2 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ECMAScript 语言中保留了很多 Java, C++ 中的关键字，其在某种意义上就是为将来的关键字而保留的单词。因此保留字不建议被用作变量名或函数名，以免在将来的 ECMAScript 语言中实现了被保留的关键字而发生不必要的异常问题。被保留关键字列表如下：<br><img src='/uploads/key_word_protect.png' /></p>
<p><font color=red><b>注意：</b>如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</font></p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/06/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%862/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maxsoft">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaxSoft">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/06/06/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%862/" class="post-title-link" itemprop="url">JavaScript基础知识整理<二>-笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表时间</span>

              <time title="创建时间：2015-06-06 20:23:02" itemprop="dateCreated datePublished" datetime="2015-06-06T20:23:02+08:00">2015-06-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天主要整理了 JavaScript 语言的历史渊源，以及其相关的组织部分。从今天开始主要总结一些 JavaScript 核心 ECMAScript 基础的语法知识，其实 ECMAScript 的语法结构和 Java 、C++ 等有许多相似之处。因为 ECMAScript 语言的设计者在当初设计该语言的时候借鉴了这些语言的相关语法结构。所以学习过 Java、C++ 的同学都比较相对容易的掌握其语法结构，笔者就是其中之一 O<sub>S</sub>O ……</p>
<h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>1&gt; <font color=red>区分大小写</font>：和 Java 语言一样，变量、函数名、运算符以及其他一切内容都是区分大小写的；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"MaxSoft"</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1992-03-13'</span>);</span><br></pre></td></tr></table></figure>
<p>2&gt; <font color=red>变量为弱类型</font>：和 Java 、C++ 等语言不同，ECMAScript 的变量没有特定的数据类型。定义变量时只用 var 运算符，可以将变量初始化为任意值。因此，在程序运行过程中可以随时改变变量所存储的数据类型；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">		obj = &#123;<span class="attr">name</span>:<span class="string">'MaxSoft'</span>,<span class="attr">age</span>:<span class="number">24</span>,<span class="attr">sex</span>:<span class="literal">false</span>&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag ==<span class="number">2</span>)&#123;</span><br><span class="line">		obj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"系统异常"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		obj();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		obj = <span class="string">"参数无效"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span>(obj));</span><br><span class="line">	<span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下图：<img src='/uploads/dynamic_type.png'><br>3&gt; <font color=red>行结束分号可有可无</font>：Java、C++ 等都要求每行代码以分号（;）结束才符合语法，而 ECMAScript 语法结构无该要求。出于 ECMAScript 程序代码的可读性与后期的可维护性，建议在编写 ECMAScript 程序时，尽量在该增加行结束标识的时候都加上结束标识符分号（;），养成一个良好的代码编写习惯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft"</span></span><br><span class="line"><span class="keyword">var</span> age=<span class="number">24</span>;</span><br></pre></td></tr></table></figure>
<p>4&gt; <font color=red>注释</font>：和 Java 语言的注释类似，有俩种：一种是单行注释（// 注释内容）； 一种是多行注释（/<em>注释内容</em>/）；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"MaxSoft"</span>; <span class="comment">// 声明姓名字段并初始化内容</span></span><br><span class="line"><span class="comment">/*获取Name字段的值*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5&gt; <font color=red>括号表示代码块</font>：从 Java 中借鉴的又一个概念是代码块。代码块表示一系列应该按顺序执行的语句，这些语句被封装在左花括号（{）和右花括号（}）之间；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doLogin</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span>(data)==<span class="string">'undefined'</span> || data == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.error(<span class="string">'表单数据为空，请检查'</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>( <span class="keyword">typeof</span>(data)==<span class="string">'object'</span> )&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'解析登录表单数据'</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'数据类型有误....'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>通过以下代码片段我们就可以更加直观的了解 ECMAScript 的语法结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> msg = <span class="string">"你好，"</span>; <span class="comment">// 申明字符串</span></span><br><span class="line">	<span class="keyword">var</span> age = <span class="number">24</span>; <span class="comment">//申明数字类型变量</span></span><br><span class="line">	alert(<span class="string">"姓名："</span>+name + <span class="string">"; 年龄："</span> + age);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"姓名："</span>+name + <span class="string">"; 年龄："</span> + age);</span><br><span class="line">	<span class="keyword">return</span> msg + name;</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">'MaxSoft'</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码执行后，通过 hello(‘MaxSoft’); 调用执行，结果如下：<br>1&gt; 首先会弹出一个弹框<img src='/uploads/hello_res.png'>2&gt; 在浏览器的控制台会输出 ：姓名：MaxSoft; 年龄：24<br>3&gt; 方法的返回值为：”你好，MaxSoft”</p>
<p><font color=red><b>注意：</b>以上代码的执行环境为 Google Chrome 浏览器；</font></p>
<p>参阅 <a href="http://www.w3school.com.cn/js/pro_js_implement.asp" target="_blank" rel="noopener">W3C School</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxsoft</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/maxsoft-bj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;maxsoft-bj" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zylwlh810@163.com" title="E-Mail → mailto:zylwlh810@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxsoft</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">91k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:23</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
